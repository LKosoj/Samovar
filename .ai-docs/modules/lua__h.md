# lua

Модуль обеспечивает интеграцию скриптового языка Lua в систему управления самоваром, позволяя гибко программировать логику работы устройства. Он предоставляет API для взаимодействия Lua-скриптов с аппаратной частью: реле, датчиками, шаговым двигателем, насосом и расширителями портов. Скрипты могут управлять режимами нагрева, клапанами, таймерами и получать данные о состоянии системы. Выполнение скриптов происходит в отдельной задаче FreeRTOS, что обеспечивает асинхронную работу без блокировки основного цикла.

Ключевые структуры данных  
luaObj — карта для хранения пользовательских переменных Lua в формате ключ-значение с пользовательским компаратором строк  
SAMOVAR_MODE — перечисление, определяющее текущий режим работы самовара (дистилляция, ректификация, пиво и т.д.)  
MESSAGE_TYPE — тип сообщения для отправки уведомлений (например, в интерфейс или лог)  
asyncHTTPrequest — Класс для асинхронного выполнения HTTP-запросов с таймаутами и обработкой ответов  
lua_State — контекст выполнения Lua-машины, используемый для обмена данными между C и Lua  
program — Массив структур, содержащих параметры программы (объём, скорость, температура и т.д.)  
SamSetup — Структура с настройками режима работы устройства  
SteamSensor, PipeSensor, WaterSensor, TankSensor, ACPSensor — Датчики температуры, содержащие поле avgTemp

---
int lua_wrapper_pinMode(lua_State *lua_state)  
Устанавливает режим работы GPIO-пина, доступного для скриптов Lua.  
Аргументы  
lua_state — указатель на состояние Lua-машины; ожидает два аргумента: номер пина и режим (INPUT/OUTPUT)  
Исключения  
Функция не возвращает значения напрямую, но может игнорировать вызовы для недопустимых пинов

---
int lua_wrapper_digitalWrite(lua_State *lua_state)  
Устанавливает логический уровень на указанном пине, включая управление насосом с ШИМ при наличии поддержки.  
Аргументы  
lua_state — указатель на состояние Lua-машины; ожидает номер пина и значение (HIGH/LOW)  
Исключения  
При записи на WATER_PUMP_PIN используется ШИМ (если включена поддержка насоса), иначе — стандартный digitalWrite

---
int lua_wrapper_digitalRead(lua_State *lua_state)  
Считывает логическое значение с указанного пина и возвращает его в Lua.  
Аргументы  
lua_state — указатель на состояние Lua-машины; ожидает номер пина  
Возвращает  
Значение HIGH или LOW, помещённое в стек Lua как число

---
int lua_wrapper_analogRead(lua_State *lua_state)  
Считывает аналоговое значение с пина LUA_PIN и возвращает его в Lua.  
Аргументы  
lua_state — указатель на состояние Lua-машины  
Возвращает  
Целое значение АЦП (0–4095), помещённое в стек Lua как число

---
int lua_wrapper_exp_pinMode(lua_State *lua_state)  
Настраивает режим пина на I2C-расширителе портов (если используется).  
Аргументы  
lua_state — указатель на состояние Lua-машины; ожидает номер пина и режим  
Исключения  
Использует семафор I2C, таймаут операции — EXPANDER_UPDATE_TIMEOUT миллисекунд

---
int lua_wrapper_exp_digitalWrite(lua_State *lua_state)  
Устанавливает уровень на пине I2C-расширителя.  
Аргументы  
lua_state — указатель на состояние Lua-машины; ожидает номер пина и значение  
Исключения  
Использует семафор I2C, таймаут операции — EXPANDER_UPDATE_TIMEOUT миллисекунд

---
int lua_wrapper_exp_digitalRead(lua_State *lua_state)  
Считывает состояние пина I2C-расширителя.  
Аргументы  
lua_state — указатель на состояние Lua-машины; ожидает номер пина  
Возвращает  
Значение пина (HIGH/LOW), помещённое в стек Lua как число

---
int lua_wrapper_exp_analogWrite(lua_State *lua_state)  
Выполняет аналоговую запись (ШИМ) на расширителе с поддержкой аналогового вывода.  
Аргументы  
lua_state — указатель на состояние Lua-машины; ожидает значение для вывода  
Исключения  
Использует семафор I2C, таймаут операции — EXPANDER_UPDATE_TIMEOUT миллисекунд

---
int lua_wrapper_exp_analogRead(lua_State *lua_state)  
Считывает аналоговое значение с I2C-аналогового расширителя.  
Аргументы  
lua_state — указатель на состояние Lua-машины; ожидает номер канала  
Возвращает  
Аналоговое значение, помещённое в стек Lua как число

---
int lua_wrapper_delay(lua_State *lua_state)  
Приостанавливает выполнение Lua-скрипта на указанное количество миллисекунд.  
Аргументы  
lua_state — указатель на состояние Lua-машины; ожидает количество миллисекунд  
Исключения  
Выполняется через vTaskDelay, не блокирует всю систему, только задачу скрипта

---
int lua_wrapper_millis(lua_State *lua_state)  
Возвращает количество миллисекунд, прошедших с момента запуска устройства.  
Аргументы  
lua_state — указатель на состояние Lua-машины  
Возвращает  
Текущее значение millis(), помещённое в стек Lua как число

---
int lua_wrapper_set_pause_withdrawal(lua_State *lua_state)  
Устанавливает состояние паузы отбора (например, при перегонке).  
Аргументы  
lua_state — указатель на состояние Lua-машины; ожидает 1 (пауза) или 0 (продолжение)  
Исключения  
Передаёт управление функции pause_withdrawal()

---
int lua_wrapper_set_power(lua_State *lua_state)  
Включает или выключает подачу мощности на ТЭН в зависимости от текущего режима работы.  
Аргументы  
lua_state — указатель на состояние Lua-машины; ожидает 1 (включить) или 0 (выключить)  
Исключения  
Функция ожидает завершения предыдущей команды через wait_command_sync() перед установкой нового режима

---
String get_lua_mode_name(bool filename)  
Возвращает имя файла Lua-скрипта, соответствующего текущему режиму самовара.  
Аргументы  
filename — если true, возвращается только имя файла; иначе — полный путь  
Возвращает  
Строка с именем или путём к Lua-скрипту, ассоциированному с текущим режимом

---
void load_lua_script()  
Загружает и компилирует Lua-скрипт, соответствующий текущему режиму работы устройства.  
Исключения  
Скрипт загружается из SPIFFS, имя определяется через get_lua_mode_name()

---
void set_power(bool On)  
Управляет включением/выключением питания ТЭНа.  
Аргументы  
On — true для включения, false для выключения  
Исключения  
Может устанавливать команду в sam_command_sync в зависимости от текущего режима

---
void SendMsg(String m, int msg_type)  
Отправляет сообщение указанного типа в систему логирования или интерфейс.  
Аргументы  
m — текст сообщения  
msg_type — тип сообщения (например, информационное, ошибка)  
Исключения  
Нет

---
String get_global_variables()  
Формирует строку с текущими глобальными переменными, доступными в Lua-среде.  
Возвращает  
Строка в формате JSON или подобном, содержащая состояние переменных из luaObj

---
void open_valve(bool Val, bool msg)  
Открывает или закрывает клапан, управляя соответствующим реле.  
Аргументы  
Val — true для открытия, false для закрытия  
msg — если true, отправляет сообщение о действии через SendMsg  
Исключения  
Нет

---
void set_current_power(float Volt)  
Устанавливает текущее значение напряжения на ТЭНе (для отображения).  
Аргументы  
Volt — значение напряжения в вольтах  
Исключения  
Нет

---
void set_body_temp()  
Обновляет температуру корпуса, измеренную датчиком.  
Исключения  
Нет

---
void set_mixer(bool On)  
Включает или выключает мешалку.  
Аргументы  
On — true для включения, false для выключения  
Исключения  
Нет

---
void set_alarm()  
Активирует сигнал тревоги (например, через зуммер или светодиод).  
Исключения  
Нет

---
void pause_withdrawal(bool Pause)  
Приостанавливает процесс отбора (например, при перегонке).  
Аргументы  
Pause — true для паузы, false для возобновления  
Исключения  
Нет

---
String getValue(String data, char separator, int index)  
Извлекает подстроку из строки по указанному разделителю и индексу.  
Аргументы  
data — исходная строка  
separator — символ-разделитель  
index — индекс требуемой части (начиная с 0)  
Возвращает  
Строка, содержащая часть, находящуюся по указанному индексу после разделения

---
String get_lua_script(String fn)  
Читает содержимое Lua-скрипта из файловой системы (SPIFFS).  
Аргументы  
fn — имя файла скрипта  
Возвращает  
Содержимое файла как строку; при ошибке возвращает пустую строку

---
void set_capacity(int cap)  
Устанавливает ёмкость ёмкости (в условных единицах) для управления процессами.  
Аргументы  
cap — значение ёмкости (0–100 или другая шкала)  
Исключения  
Нет

---
float get_alcohol(float t)  
Рассчитывает концентрацию алкоголя по температуре пара.  
Аргументы  
t — температура в градусах Цельсия  
Возвращает  
Оценка крепости (объёмные проценты) спирта при заданной температуре

---
float get_temp_by_pressure(float start_pressure, float start_temp, float current_pressure)  
Вычисляет температуру по текущему давлению, используя начальные данные.  
Аргументы  
start_pressure — начальное давление  
start_temp — начальная температура  
current_pressure — текущее давление  
Возвращает  
Рассчитанная температура, соответствующая текущему давлению

---
bool set_mixer_pump_target(int on)  
Устанавливает целевое состояние насоса-мешалки (если используется).  
Аргументы  
on — 1 для включения, 0 для выключения  
Возвращает  
true при успешной установке, false при ошибках (например, отсутствии поддержки)

---
bool set_stepper_by_time(uint16_t spd, uint8_t direction, uint16_t time)  
Управляет шаговым двигателем, задавая скорость, направление и время работы.  
Аргументы  
spd — скорость (значение ШИМ)  
direction — направление (0 или 1)  
time — продолжительность работы в миллисекундах  
Возвращает  
true, если двигатель запущен; false, если недоступен или ошибка инициализации

---
void do_lua_script(void *parameter)  
Задача FreeRTOS для выполнения Lua-скрипта в фоновом режиме.  
Аргументы  
parameter — параметр задачи (не используется)  
Исключения  
Функция работает как задача FreeRTOS, завершается при окончании скрипта или остановке

---
int lua_wrapper_set_samovar_mode(lua_State *lua_state)  
Устанавливает режим работы самовара на основе переданного числового значения.  
Аргументы  
lua_state — указатель на состояние Lua, содержит аргументы вызова  
Возвращает  
0 — всегда возвращает 0 для соответствия сигнатуре функции Lua  
Исключения  
Отсутствуют

---
int lua_wrapper_set_mixer(lua_State *lua_state)  
Активирует или деактивирует мешалку с заданной интенсивностью.  
Аргументы  
lua_state — указатель на состояние Lua, первый аргумент — целое число (уровень интенсивности)  
Возвращает  
0 — всегда возвращает 0  
Исключения  
Отсутствуют

---
int lua_wrapper_open_valve(lua_State *lua_state)  
Открывает или закрывает клапан в зависимости от переданного значения.  
Аргументы  
lua_state — указатель на состояние Lua, первый аргумент — булево значение (true — открыть, false — закрыть)  
Возвращает  
0 — всегда возвращает 0  
Исключения  
Отсутствуют

---
int lua_wrapper_set_current_power(lua_State *lua_state)  
Устанавливает текущую мощность нагрева (доступно только при определении SAMOVAR_USE_POWER).  
Аргументы  
lua_state — указатель на состояние Lua, первый аргумент — число с плавающей точкой (мощность в долях от 0 до 1)  
Возвращает  
0 — всегда возвращает 0  
Исключения  
Отсутствуют

---
int lua_wrapper_set_alarm(lua_State *lua_state)  
Инициирует срабатывание сигнала тревоги.  
Аргументы  
lua_state — указатель на состояние Lua  
Возвращает  
0 — всегда возвращает 0  
Исключения  
Отсутствуют

---
int lua_wrapper_set_body_temp(lua_State *lua_state)  
Устанавливает температуру корпуса как текущую целевую (используется в определённых режимах).  
Аргументы  
lua_state — указатель на состояние Lua  
Возвращает  
0 — всегда возвращает 0  
Исключения  
Отсутствуют

---
int lua_wrapper_set_next_program(lua_State *lua_state)  
Переходит к следующему этапу программы в зависимости от текущего режима самовара.  
Аргументы  
lua_state — указатель на состояние Lua  
Возвращает  
0 — всегда возвращает 0  
Исключения  
Отсутствуют

---
int lua_wrapper_get_state(lua_State *lua_state)  
Возвращает текущее числовое состояние самовара (код статуса).  
Аргументы  
lua_state — указатель на состояние Lua  
Возвращает  
1 — количество возвращаемых значений (текущий SamovarStatusInt)  
Исключения  
Отсутствуют

---
int lua_wrapper_send_msg(lua_State *lua_state)  
Отправляет текстовое сообщение либо в консоль, либо через систему уведомлений.  
Аргументы  
lua_state — указатель на состояние Lua, первый аргумент — сообщение, второй — тип сообщения (-1 для лога, иначе MESSAGE_TYPE)  
Возвращает  
0 — всегда возвращает 0  
Исключения  
Отсутствуют

---
int lua_wrapper_set_num_variable(lua_State *lua_state)  
Устанавливает значение числовой переменной по её имени (через строку).  
Аргументы  
lua_state — указатель на состояние Lua, первый аргумент — имя переменной, второй — значение  
Возвращает  
0 — всегда возвращает 0  
Исключения  
Отсутствуют

---
int lua_wrapper_get_num_variable(lua_State *lua_state)  
Возвращает значение числовой переменной по её имени.  
Аргументы  
lua_state — указатель на состояние Lua, первый аргумент — имя переменной  
Возвращает  
1 — количество возвращаемых значений (числовое значение переменной)  
Исключения  
Отсутствуют

---
int lua_wrapper_set_str_variable(lua_State *lua_state)  
Устанавливает значение строковой переменной по её имени.  
Аргументы  
lua_state — указатель на состояние Lua-машины, содержащее имя и значение переменной в стеке  
Возвращает  
Количество возвращаемых значений (0)  
Исключения  
Нет

---
int lua_wrapper_set_object(lua_State *lua_state)  
Сохраняет строковое значение в пользовательский объект luaObj по ключу.  
Аргументы  
lua_state — указатель на состояние Lua-машины, содержащее ключ и значение в стеке  
Возвращает  
Количество возвращаемых значений (0)  
Исключения  
Нет

---
int lua_wrapper_get_object(lua_State *lua_state)  
Возвращает значение из пользовательского объекта luaObj по ключу, с опциональной обработкой типа.  
Аргументы  
lua_state — указатель на состояние Lua-машины, содержащее ключ и, опционально, тип значения  
Возвращает  
Количество возвращаемых значений в стеке Lua (1 — строка)  
Исключения  
Нет

---
int lua_wrapper_set_lua_status(lua_State *lua_state)  
Устанавливает глобальное строковое состояние Lua-скрипта.  
Аргументы  
lua_state — указатель на состояние Lua-машины, содержащее новое значение статуса  
Возвращает  
Количество возвращаемых значений (0)  
Исключения  
Нет

---
int lua_wrapper_set_capacity(lua_State *lua_state)  
Устанавливает текущую ёмкость системы.  
Аргументы  
lua_state — указатель на состояние Lua-машины, содержащее номер ёмкости как число  
Возвращает  
Количество возвращаемых значений (0)  
Исключения  
Нет

---
int lua_wrapper_set_pump_pwm(lua_State *lua_state)  
Устанавливает широтно-импульсную модуляцию (PWM) для насоса воды.  
Аргументы  
lua_state — указатель на состояние Lua-машины, содержащее значение PWM (0–255)  
Возвращает  
Количество возвращаемых значений (0)  
Исключения  
Нет

---
int lua_wrapper_set_timer(lua_State *lua_state)  
Устанавливает таймер с задержкой в секундах.  
Аргументы  
lua_state — указатель на состояние Lua-машины, содержащее номер таймера (1–9) и значение задержки в секундах  
Возвращает  
Количество возвращаемых значений (0)  
Исключения  
Нет

---
int lua_wrapper_get_timer(lua_State *lua_state)  
Возвращает оставшееся время указанного таймера в миллисекундах.  
Аргументы  
lua_state — указатель на состояние Lua-машины, содержащее номер таймера (1–9)  
Возвращает  
Количество возвращаемых значений в стеке Lua (1 — оставшееся время в миллисекундах или 0, если таймер неактивен)  
Исключения  
Нет

---
int lua_wrapper_get_free_heap(lua_State *lua_state)  
Возвращает текущий объём свободной кучи в килобайтах.  
Возвращает  
Число свободной памяти в КБ

---
int lua_wrapper_get_str_variable(lua_State *lua_state)  
Получает значение строковой переменной по имени из глобального контекста.  
Аргументы  
1 — Имя переменной в виде строки (например, "Msg", "SamovarStatus")  
Возвращает  
Значение переменной как строка; в случае неизвестного имени — логирование и возврат 0

---
int lua_wrapper_http_request(lua_State *lua_state)  
Выполняет HTTP-запрос с поддержкой методов GET и POST.  
Аргументы  
1 — URL-адрес как строка  
2 — (опционально) тип запроса (например, "POST")  
3 — (опционально) заголовок Content-Type  
4 — (опционально) тело запроса  
Возвращает  
Текст ответа на запрос или "error" при таймауте/ошибке

---
int lua_wrapper_set_stepper_by_time(lua_State *lua_state)  
Устанавливает параметры шагового двигателя: скорость, направление и время работы.  
Аргументы  
1 — Скорость в шагах в секунду (uint16_t)  
2 — Направление (0 — вперёд, 1 — назад, uint8_t)  
3 — Время работы в миллисекундах (uint16_t)  
Возвращает  
Результат вызова set_stepper_by_time как число

---
int lua_wrapper_set_stepper_target(lua_State *lua_state)  
Устанавливает целевое положение шагового двигателя.  
Аргументы  
1 — Скорость в шагах в секунду (uint16_t)  
2 — Направление (uint8_t)  
3 — Целевое количество шагов (uint32_t)  
Возвращает  
Результат вызова set_stepper_target как число

---
int lua_wrapper_get_stepper_status(lua_State *lua_state)  
Получает текущий статус шагового двигателя.  
Возвращает  
Текущий статус двигателя (например, 0 — остановлен, 1 — движение)

---
int lua_wrapper_i2cpump_start(lua_State *lua_state)  
Запускает I2C-насос с заданной скоростью и объёмом.  
Аргументы  
1 — Скорость подачи (в относительных единицах, float)  
2 — Объём в мл, который нужно подать (float)  
Возвращает  
Результат вызова set_stepper_target (0 при ошибке, иначе код старта)

---
int lua_wrapper_i2cpump_stop(lua_State *lua_state)  
Останавливает I2C-насос и сбрасывает целевые параметры.  
Возвращает  
0, если устройство не поддерживает I2C-насос; иначе не возвращает значения (выполняет остановку)

---
int lua_wrapper_i2cpump_get_speed(lua_State *lua_state)  
Возвращает текущую скорость I2C-насоса.  
Аргументы  
lua_state — указатель на состояние Lua  
Возвращает  
Текущая скорость насоса в мл/мин (число), 0 если устройство не активно  
Исключения  
Нет

---
int lua_wrapper_i2cpump_get_target_ml(lua_State *lua_state)  
Возвращает целевой объём дозирования в миллилитрах.  
Аргументы  
lua_state — указатель на состояние Lua  
Возвращает  
Целевой объём в мл, 0 если устройство не активно  
Исключения  
Нет

---
int lua_wrapper_i2cpump_get_remaining_ml(lua_State *lua_state)  
Возвращает оставшийся объём жидкости для дозирования в миллилитрах.  
Аргументы  
lua_state — указатель на состояние Lua  
Возвращает  
Оставшийся объём в мл, вычисленный по шагам двигателя, 0 если устройство не активно  
Исключения  
Нет

---
int lua_wrapper_i2cpump_get_running(lua_State *lua_state)  
Проверяет, работает ли насос в данный момент.  
Аргументы  
lua_state — указатель на состояние Lua  
Возвращает  
1 если насос активен и ещё не достиг цели, иначе 0  
Исключения  
Нет

---
int lua_wrapper_set_mixer_pump_target(lua_State *lua_state)  
Устанавливает целевое положение насоса смесителя.  
Аргументы  
lua_state — указатель на состояние Lua, содержит целевое значение (в шагах или условных единицах)  
Возвращает  
Результат установки (статус), передаётся в Lua как число  
Исключения  
Нет

---
int lua_wrapper_get_mixer_pump_status(lua_State *lua_state)  
Возвращает текущий статус насоса смесителя.  
Аргументы  
lua_state — указатель на состояние Lua  
Возвращает  
Текущее состояние насоса смесителя (число)  
Исключения  
Нет

---
int lua_wrapper_check_I2C_device(lua_State *lua_state)  
Проверяет наличие I2C-устройства по заданному адресу.  
Аргументы  
lua_state — указатель на состояние Lua, содержит адрес устройства на стеке  
Возвращает  
1 если устройство отвечает, иначе 0  
Исключения  
Нет

---
int lua_wrapper_set_i2c_rele_state(lua_State *lua_state)  
Устанавливает состояние реле на I2C-расширителе.  
Аргументы  
lua_state — указатель на состояние Lua, содержит номер реле и целевое состояние  
Возвращает  
Результат операции (1 — успех, 0 — ошибка)  
Исключения  
Нет

---
int lua_wrapper_get_i2c_rele_state(lua_State *lua_state)  
Читает текущее состояние указанного реле на I2C-расширителе.  
Аргументы  
lua_state — указатель на состояние Lua, содержит номер реле  
Возвращает  
Текущее состояние реле (1 — включено, 0 — выключено)  
Исключения  
Нет

---
void ua_register(const char* name, const lua_CFunction func)  
Регистрирует C-функцию как доступную в Lua под именем "set_i2c_rele_state".  
Аргументы  
name — Имя функции, доступное в Lua  
func — Указатель на C-функцию-обёртку

---
String get_lua_script_list()  
Возвращает список доступных Lua-скриптов для текущего режима, начинающихся с "btn_", в формате строки с разделителями.  
Возвращает  
Строка в формате "имя_файла|отображаемое_имя,..." для всех подходящих скриптов

---
void run_lua_script(String fn)  
Загружает и подготавливает к выполнению Lua-скрипт по имени файла, добавляя глобальные переменные.  
Аргументы  
fn — Имя файла скрипта

---
String run_lua_string(String lstr)  
Выполняет переданную строку как Lua-скрипт с логированием и отправкой через MQTT (при включении USE_MQTT).  
Аргументы  
lstr — Lua-код в виде строки  
Возвращает  
Результат выполнения (ошибка или пустая строка)

---
void start_lua_script()  
Инициирует выполнение Lua-скриптов, устанавливая флаг lua_finished в false

---
String getVariables()  
Формирует строку с текущими значениями переменных состояния системы в формате "имя=значение".  
Возвращает  
Строка с перечислением переменных и их значений, разделённых символами \r\n
