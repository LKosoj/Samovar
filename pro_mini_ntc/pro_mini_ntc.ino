//=================================================БИБЛИОТЕКИ==============================================================
 #include <Arduino.h>
 #include <Wire.h>
 #include <avr/wdt.h>  // watchdog (по моему нихрена оно не работает, но пусть уж будет)
 #include "OneWireHub.h"
 #include "DS18B20.h"
 #include <ASOLED.h>     // Библиотека дисплея
 #include <XGZP6897D.h>  // Библиотека датчика давления XGZP6897D
 #include "HX710B.h"     // Библиотека датчика давления на АЦП HX710B
 #include <EEPROM.h>

//=================================================ИСХОДНЫЕ КОНСТАНТЫ, ПЕРЕМЕННЫЕ, ОБЪЕКТЫ=================================
//                                                   то, что можно менять помечено *
//------------------------------------------Значения для режима килоомметра (включается при зажатой во время загрузки кнопкой действия, либо закороченном первом термисторе) и рассчета характеристик термисторов
 float U33 = 3.33;    // * точное напряжение на пине 3.3 V
 float Uref = 2.047;  // * опорное напряжение, точное напряжение на пине A0 ADS1115 без подключенного делителя
 float R62 = 6.200;   // * точное значение 6.2 кОм резистора
 float R10 = 9.990;   // * точное значение 10 кОм резистора
 float B25 = 3950, B25t = 3950; // * характеристика термисторов
 uint8_t Mode_R = 0;  // триггер режима килоомметра
 uint8_t ADSCh = 0;   // * канал измерений килоомметра
//------------------------------------------Значения для датчиков давления-------------------------------------------------
 int8_t Pressure_enable[4] = {0, 0, 0 ,0};   // Признаки наличия датчиков давления, вычисляемый, для XGZP6897D = 1 (установится если откликнется по I2C),
                              // для MPX10DP = 2 (установится если стоит перемычка с D8 на массу), для HX710B =3 (установится если стоит перемычка с D7 на массу)
 float pressure[4], temperature[4];  // переменные для чтения датчиков давления
//                                          Датчик XGZP6897D, подключенный к I2C №1
 XGZP6897D XGZP6897D(512);  // Объект датчика давления с делителем К=512, делитель зависит от диапазона датчика, искать в даташите, мой (0 - 10 Pa)
 float dPress_1 = 0;         // * Поправка для датчика давления, равна его среднему значению при отсутствии давления и нулевой поправке
 float KTemp_1 = 0;            // * Коэффициент термокомпенсации (наклон кривой), требуется подбор, зависит от выходного диапазона напряжений датчика (при моих экспериментах работает с 0.8-1)
 float BaseTemp_1 = 26.50;  // * Базовая температура для термокомпенсации, можно увидеть на экране настройки датчика давления при реальном давлении =0
  // и после выдержки во включенном состоянии минут 15.
 float dPt_1 = 0;                 // Вычисляемая поправка термокомпенсации
 /*   K value for XGZP6897D. It depend on the pressure range of the sensor.
   Table found in the data sheet from CFSensor.com
    https://cfsensor.com/product-category/i2c-sensor/https://cfsensor.com/product-category/i2c-sensor/
  pressure_range (kPa)   K value
  131<P≤260               32
  65<P≤131                64
  32<P≤65                 128
  16<P≤32                 256
  8<P≤16                  512
  4<P≤8                   1024
  2≤P≤4                   2048
  1≤P<2                   4096
  P<1                     8192
  the K value is selected according to the positive pressure value only,
  like -100～100kPa,the K value is 64.*/
//                                          Датчики подключенные к 8 каналу АЦП (MPX10DP и т.п.) №2
 float ADSt1, ADSt= 23000;  // Переменные для временного хранения
 float PressureBaseADS = 23000;  // * ADS нулевого давления при базовой температуре, узнать величину можно на экране настройки датчика давления при реальном давлении =0 и после выдержки во включенном состоянии минут 15
 float PressureQ = 0.0227273;             // * Квант изменения давления (мм.рт.ст.), на сколько изменится давление при приросте значения от АЦП на 1, для своего датчика надо считать свой, если подключить датчик не напрямую, а через делитель 6.2/10 кОм он будет около 0.3149
 float KTemp_2 = 0.51;            // * Коэффициент термокомпенсации (наклон кривой), требуется подбор, зависит от выходного диапазона напряжений датчика (при моих экспериментах работает с 0.8-1)
 float BaseTemp_2 = 22.70;  // * Базовая температура для термокомпенсации, для MPX10DP и подобных можно увидеть на экране настройки датчика давления при реальном давлении =0
   // и после выдержки во включенном состоянии минут 15.
 float dPress_2 = 0;         // Поправка для датчика давления, равна его среднему значению при отсутствии давления и нулевой поправке,
                                // её можно изменить на свою, но правильнее менять PressureBaseADS 
 float dPt_2 = 0;                 // Вычисляемая поправка термокомпенсации
//                                          Датчик 040DR1 на АЦП HX710B (0-40кПа) и ему подобные, MPS20N0040D-S например №3
 const int SCLK = 4;  // Ноги ардуины
 const int DOUT = 3;
 HX710B HX710B_Obj;                // Объект датчика
 float HX710B_Mult = 4.35;         // * Множитель для врунишки чтоб не лезть в библиотеку, характеристика всё равно линейная, ставите 1 и вычисляете при поверке с манометром
 float KTemp_3 = 0.00;             // * Коэффициент термокомпенсации (наклон кривой), требуется подбор, зависит от выходного диапазона напряжений датчика (при моих экспериментах работает с 0.8-1)
 float BaseTemp_3 = 27.57;         // * Базовая температура для термокомпенсации, можно увидеть на экране настройки датчика давления при реальном давлении =0
   // и после выдержки во включенном состоянии минут 15.
 float dPress_3 = 57.41;           // * Поправка для датчика давления, равна его среднему значению при отсутствии давления и нулевой поправке,
                                   // её можно изменить на свою, (-11.46 для моего HX710B)
 float Pressure3Temp, 
       dPt_3 = 0;                  // Вычисляемая поправка термокомпенсации
// -----------------------------------------Электронный попугай------------------------------------------------------------
 uint8_t N_dPressure=0;             // * Номер датчика давления электронного попугая (0-3), 0 - для отключения попугая
 float k_Alc_T=0.3;                 // * Коэффициент для температурной коррекции, 0 - для отключения
 float k_Alc=136;                   // * Коэффициент перевода давления в плотность =G(г/мл)*10000/P (мм.рт.с.)=10*133,322(мм.рт.ст->Па)/(g(9.8 м/с)*h(высота столба жидкости попугая 1 м))
 float Alc=0;                       // Рассчетная крепость 
 float Alc_T=0;                     // Рассчетная крепость с коррекцией по t6  
 float Alc_tar=0;                   // * Крепость раствора для тарирования
// -----------------------------------------Для взаимодействия с пользователем---------------------------------------------
 const int BtnEnter = 12;          // кнопка действия: на 1 экране отображения сброс дрейфа нуля датчика давления
 int BtnEnterFlg = 0;
 const int BtnSel = 10;            // кнопка переключения экранов отображения
 int BtnSelFlg = 0;
 const int BtnUp = 9;              // кнопка +
 const int BtnDwn = 11;            // кнопка -
 int8_t DispMode = 0;              // счетчик для для экранов отображения
 static char outstr[8];            // строка для вывода цифр на экран
 constexpr uint8_t pin_led{ 13 };  // мигаем светодиодом на ардуине для контроля передачи по 1Ware
 unsigned long timer;              // таймер для отображения при отсутствии соединения по 1Wire
 bool Rec=1;                       // флаг для отображения факта записи значения
//----------------------------------------- Работа с EEPROM ---------------------------------------------------------------
 const uint8_t EepromKey = 1;      // ключ EEPROM 0-255, менять для сброса EEPROM
 const uint16_t U33_EAdr = 1; 
 const uint16_t Uref_EAdr = 5;
 const uint16_t R62_EAdr = 9;
 const uint16_t R10_EAdr = 13;
 const uint16_t B25_EAdr = 17;
 const uint16_t dPress_1_EAdr = 21;
 const uint16_t KTemp_1_EAdr = 25;
 const uint16_t BaseTemp_1_EAdr = 29; 
 const uint16_t PressureBaseADS_EAdr = 33;
 const uint16_t PressureQ_EAdr = 37;
 const uint16_t KTemp_2_EAdr = 41;
 const uint16_t BaseTemp_2_EAdr = 45;
 const uint16_t HX710B_Mult_EAdr = 49;
 const uint16_t KTemp_3_EAdr = 53;
 const uint16_t BaseTemp_3_EAdr = 57;
 const uint16_t dPress_3_EAdr = 61;
 const uint16_t m_adc_EAdr = 65;
 const uint16_t N_dPressure_EAdr= 367;
 const uint16_t k_Alc_T_EAdr= 371;
 const uint16_t k_Alc_EAdr= 375;
 // Адрес свободной ячейки EEPROM 379
//------------------------------------------Для считывания значений с АЦП--------------------------------------------------
 float Temp[9];         // массив текущих температур, чтоб не читать по 2 раза за цикл
 #define ADS_Trg 30100  // * Предел для определения подключенных термисторов, в исходнике был 32750, у меня, как оказалось, он должен быть меньше, если оставить \
                       // прежний Самовар из предлагаемых 9 датчиков выбирает себе какие то 5 и глючит, т.к. некоторых в реальности нет.
 #define ADS_I2CADDR_1 (0x48)
 #define ADS_I2CADDR_2 (0x49)
 #define ADS1115_REG_CONFIG_MUX_SINGLE_0 (0x4000)
 #define ADS1115_REG_CONFIG_MUX_SINGLE_1 (0x5000)
 #define ADS1115_REG_CONFIG_MUX_SINGLE_2 (0x6000)
 #define ADS1115_REG_CONFIG_MUX_SINGLE_3 (0x7000)
 #define ADS1115_REG_POINTER_CONVERT (0x00)
 #define ADS1115_REG_POINTER_CONFIG (0x01)

// -----------------------------------------Для передачи данных по 1Ware---------------------------------------------------
 bool OneWireConnectDetected = false;                              // триггер для определения факта соединения по 1Wire
 uint8_t ntcEn[9];                                                 // Массив флагов наличия подключенных датчиков
 constexpr uint8_t pin_onewire{ 2 };                               // Pin передачи по протоколу 1Ware
 auto hub = OneWireHub(pin_onewire);                               // Объект 1Ware хаба
 auto ds18bP = DS18B20(0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22);  // 0x55 Адрес для датчика давления, байт 0x55 вычисляемый в OneWireItem.cpp
                                                                  // в OneWireHub_Config.h изменён параметр #define HUB_SLAVE_LIMIT 9 (было 8)
 auto ds18b1 = DS18B20(0x28, 0x10, 0x55, 0x44, 0x33, 0x22, 0x01);  // 0xD8
 auto ds18b2 = DS18B20(0x28, 0x20, 0x55, 0x44, 0x33, 0x22, 0x02);  // 0xD7
 auto ds18b3 = DS18B20(0x28, 0x30, 0x55, 0x44, 0x33, 0x22, 0x03);  // 0xD2
 auto ds18b4 = DS18B20(0x28, 0x40, 0x55, 0x44, 0x33, 0x22, 0x04);  // 0xC9
 auto ds18b5 = DS18B20(0x28, 0x50, 0x55, 0x44, 0x33, 0x22, 0x05);  // 0xCC
 auto ds18b6 = DS18B20(0x28, 0x60, 0x55, 0x44, 0x33, 0x22, 0x06);  // 0xC3
 auto ds18b7 = DS18B20(0x28, 0x70, 0x55, 0x44, 0x33, 0x22, 0x07);  // 0xC6
 auto ds18b8 = DS18B20(0x28, 0x80, 0x55, 0x44, 0x33, 0x22, 0x08);  // 0xF5

// ---------------------------------------* Включение отладки с выдачей значений в СОМ порт (без передачи данных по 1Ware)-
 //#define SERIAL_DEBUG
 //#define SERIAL_TEST_NTC
 uint32_t millisConvert;  // для рассчета длительности инициализации при отладке


/*--------------------------------------- * С какой характеристикой В(25/100) подключены NTC-термисторы ------------------- */
 float T25 = 25;      // * температура для расчета B25
 float T100 = 100;    // * температура для расчета B25 
 float R25 = 10;      // * точное значение сопротивления терморезистора при 25 гр.Ц, кОм
 float R100 = 0.685;  // * точное значение сопротивления терморезистора при 100 гр.Ц, кОм
 float Ttemp=-25;
 #define ChinaNTC /* B(25/100) = ???? */  //Вариант, когда датчики "китай", либо напряжение питания АЦП отличается от 3,3 В, \
                                         //либо резисторы не совсем 10/6.2 кОм, если абсолютная точность не особо важна \
                                         //можно просто выбрать из тех, что ниже, относительная точность не изменится
 //#define B4300    /* B(25/100) = 4300 */
 //#define B3988    /* B(25/100) = 3988 */
 //#define B3950    /* B(25/100) = 3950 */
 //#define B3625    /* B(25/100) = 3625 */
 //#define B3530    /* B(25/100) = 3530 */
 //#define B3492    /* B(25/100) = 3492 */
 /* NTC-термисторы c характеристикой B(25/100) = 3380, если все остальные закомментированы */
 /*                                            ДЛЯ ТЕХ У КОГО НЕТ ТОЧНЫХ ПРИБОРОВ
          Подбор резисторов в процессе сборки: 
         Понадобится два эталонных 6.2 и 10 кОм, если нету можно попросить у имеющих точные приборы выставить их на многооборотных подстроечниках, 
         впринципе даже на всех, тогда дальше можно не читать.
         Сначала собираем АЦП с одним первым можно и не очень, но лучше точным делителем 6.2/10 кОм, 
         вписываем их значения в константы ниже. Вольтметром меряем напряжение питания 3.3 В и референсное с ноги А0, 
         вписываем их ниже. Прошиваемся уже с выбранной и возможно рассчитанной характеристикой В, см. выше и ниже.
         Паяем вместо первого терморезистора 2 зажима. Перезагружаемся с зажатой кнопкой действия
         либо с соединенными между собой зажимами, на дисплее появятся значения с 1 канала: ADS 15 битовое с АЦП,
         рассчитанные: измеренное АЦП напряжение, общее сопротивление параллельных R 10 кОм и измеряемого, 
         и нижнее измеряемое сопротивление кОм. (если канал окажется не первым, кнопкой действия листаем до него) 
         Измерения скорей всего не особо правильное, особенно с резисторами 6.2 кОм, потому что врядли все использованные
         сопротивления и напряжения равны требуемым, но позволяют подбирать резисторы одинаковыми с точностью до третьего знака после запятой. 
         Мне проще было ориентироваться по значению ADS, тогда можно ниже значения сопротивлений и напряжений не вписывать.
         Подбираем сопротивления 10 и 6.2 кОМ так, чтобы цифры ADS и соответственно Рассчитанного сопротивления были как можно более похожи 
         на измеренные на эталонных, опять таки здесь удобно использовать многооборотные подстроечники 20 кОм. 
         Впаиваем все делители из подобранных. Теперь у вас все делители максимально похожи между собой и близки к 10/6.2 кОм, 
         строим характеристику B для них и прошиваемся ещё раз*/
 /*  Таблицы суммарного значения АЦП в зависимости от температуры. От большего значения к меньшему
 *  Для построения таблицы использованы следующие парамертры:
 *    R1(T1): 10кОм(25°С)
 *    Схема включения: Ra подключен к U0, Rb параллельно R1(T1)
 *    Ra/Rb: 6.2кОм/10кОм
 *    Напряжения U0/Uref: 3.3В/2.047В */
 #if defined(ChinaNTC)  // * Эта таблица под мои текущие термисторы, напряжение и делитель \
                       // Таблицу под свои термисторы, Ra/Rb и напряжение питания АЦП можно получить здесь https://aterlux.ru/article/ntcresistor \
                       // какие исходные параметры вставлять читать здесь https://forum.homedistiller.ru/msg.php?id=13976866 и здесь https://forum.homedistiller.ru/msg.php?id=14020829
                       /*         ChinaNTC          */
  uint16_t m_adc[151] = { 32101, 32049, 31993, 31935, 31874, 31810, 31742, 31670, 31595, 31516, 31433, 31346, 31255, 31160, 31060, 30956, 30847, 30732, 30614, 30489, 30360, 30226, 30085, 29940,
                          29789, 29632, 29469, 29300, 29126, 28945, 28758, 28566, 28367, 28162, 27951, 27733, 27510, 27280, 27045, 26803, 26556, 26303, 26044, 25780, 25510, 25235, 24954, 24669,
                          24379, 24085, 23786, 23483, 23176, 22865, 22551, 22234, 21914, 21592, 21267, 20940, 20612, 20282, 19951, 19619, 19286, 18954, 18621, 18288, 17956, 17625, 17296, 16967,
                          16640, 16315, 15992, 15672, 15354, 15039, 14726, 14417, 14112, 13809, 13511, 13216, 12925, 12638, 12355, 12076, 11802, 11532, 11267, 11006, 10749, 10497, 10250, 10007,
                          9769, 9536, 9307, 9083, 8864, 8649, 8439, 8233, 8032, 7835, 7643, 7455, 7272, 7092, 6917, 6746, 6579, 6416, 6257, 6102, 5951, 5803, 5660, 5519,
                          5383, 5249, 5119, 4993, 4870, 4749, 4632, 4518, 4407, 4299, 4194, 4091, 3991, 3894, 3799, 3707, 3617, 3529, 3444, 3361, 3281, 3202, 3125, 3051,
                          2978, 2908, 2839, 2772, 2707, 2643, 2582 };
 #elif defined(B4300)
  /*         B25/100: 4300         */
  uint16_t m_adc[151] = { 31924, 31877, 31827, 31774, 31719, 31659, 31597, 31531, 31461, 31388, 31310, 31229, 31143, 31052, 30958, 30858, 30754, 30644, 30530, 30410, 30284, 30153, 30016, 29873,
                          29724, 29569, 29408, 29241, 29067, 28886, 28699, 28505, 28304, 28097, 27883, 27662, 27434, 27199, 26958, 26710, 26455, 26194, 25926, 25652, 25372, 25086, 24794, 24496,
                          24193, 23885, 23571, 23254, 22931, 22605, 22274, 21941, 21604, 21264, 20921, 20576, 20230, 19881, 19532, 19182, 18831, 18480, 18129, 17779, 17430, 17082, 16735, 16390,
                          16047, 15706, 15368, 15033, 14702, 14373, 14048, 13727, 13410, 13097, 12788, 12484, 12184, 11889, 11599, 11313, 11033, 10758, 10488, 10223, 9963, 9709, 9460, 9216,
                          8977, 8743, 8515, 8292, 8074, 7861, 7653, 7450, 7252, 7059, 6871, 6687, 6508, 6334, 6164, 5999, 5838, 5681, 5529, 5380, 5236, 5095, 4958, 4825, 4696, 4570, 4448, 4329,
                          4214, 4101, 3992, 3886, 3783, 3683, 3585, 3491, 3399, 3310, 3223, 3139, 3057, 2977, 2900, 2825, 2752, 2681, 2612, 2545, 2480, 2417, 2356, 2296, 2238, 2182, 2127 };
 #elif defined(B3988)
  /*         B25/100: 3988         */
  uint16_t m_adc[151] = { 31771, 31718, 31662, 31603, 31541, 31475, 31406, 31334, 31258, 31178, 31095, 31007, 30916, 30820, 30720, 30615, 30505, 30391, 30273, 30149, 30020, 29886, 29747, 29602,
                          29452, 29296, 29135, 28968, 28796, 28617, 28433, 28243, 28048, 27846, 27638, 27425, 27206, 26981, 26750, 26514, 26272, 26024, 25772, 25513, 25250, 24982, 24709, 24431,
                          24149, 23862, 23571, 23277, 22979, 22677, 22372, 22064, 21753, 21440, 21125, 20808, 20489, 20169, 19848, 19525, 19203, 18880, 18557, 18234, 17912, 17590, 17270, 16951,
                          16633, 16317, 16003, 15691, 15381, 15074, 14770, 14469, 14171, 13876, 13584, 13296, 13011, 12731, 12454, 12181, 11912, 11648, 11387, 11131, 10879, 10631, 10388, 10149,
                          9915, 9685, 9459, 9238, 9021, 8808, 8600, 8396, 8197, 8002, 7811, 7624, 7442, 7263, 7089, 6918, 6752, 6589, 6430, 6275, 6124, 5976, 5832, 5691, 5554, 5420, 5289, 5162,
                          5038, 4917, 4798, 4683, 4571, 4462, 4355, 4251, 4150, 4051, 3955, 3862, 3770, 3681, 3595, 3510, 3428, 3348, 3270, 3194, 3120, 3047, 2977, 2908, 2842, 2777, 2713 };
 #elif defined(B3950)
  /*         B25/100: 3950         */
  uint16_t m_adc[151] = { 31751, 31697, 31640, 31580, 31517, 31450, 31381, 31308, 31231, 31151, 31066, 30978, 30886, 30789, 30688, 30583, 30473, 30359, 30239, 30115, 29986, 29852, 29712, 29567,
                          29417, 29262, 29101, 28934, 28762, 28584, 28400, 28211, 28015, 27815, 27608, 27396, 27178, 26954, 26724, 26490, 26249, 26004, 25753, 25496, 25235, 24969, 24698, 24423,
                          24143, 23859, 23571, 23280, 22984, 22686, 22384, 22079, 21772, 21462, 21150, 20836, 20521, 20204, 19886, 19567, 19248, 18928, 18609, 18289, 17970, 17652, 17335, 17019,
                          16704, 16391, 16080, 15771, 15464, 15160, 14859, 14560, 14264, 13971, 13682, 13396, 13114, 12835, 12560, 12289, 12021, 11758, 11499, 11244, 10993, 10747, 10504, 10266,
                          10033, 9803, 9578, 9357, 9141, 8928, 8721, 8517, 8317, 8122, 7931, 7744, 7561, 7383, 7208, 7037, 6870, 6707, 6547, 6391, 6239, 6091, 5946, 5804, 5666, 5531, 5400, 5272,
                          5147, 5024, 4905, 4789, 4676, 4566, 4458, 4353, 4251, 4151, 4054, 3959, 3866, 3776, 3689, 3603, 3520, 3438, 3359, 3282, 3207, 3134, 3062, 2992, 2925, 2858, 2794 };
 #elif defined(B3625)
  /*         B25/100: 3625         */
  uint16_t m_adc[151] = { 31550, 31490, 31426, 31359, 31289, 31217, 31140, 31061, 30978, 30891, 30801, 30707, 30609, 30507, 30402, 30292, 30178, 30059, 29937, 29810, 29678, 29542, 29401, 29256,
                          29106, 28951, 28792, 28627, 28458, 28284, 28105, 27921, 27733, 27540, 27341, 27138, 26931, 26718, 26501, 26280, 26054, 25823, 25589, 25350, 25107, 24860, 24609, 24355,
                          24097, 23836, 23571, 23304, 23033, 22760, 22485, 22207, 21926, 21644, 21360, 21075, 20788, 20500, 20211, 19922, 19631, 19341, 19050, 18759, 18469, 18179, 17889, 17601,
                          17313, 17027, 16742, 16458, 16176, 15896, 15618, 15342, 15068, 14796, 14527, 14261, 13997, 13736, 13478, 13223, 12971, 12722, 12476, 12233, 11994, 11758, 11526, 11297,
                          11072, 10850, 10631, 10416, 10205, 9997, 9793, 9592, 9395, 9201, 9011, 8824, 8641, 8461, 8285, 8112, 7942, 7776, 7613, 7453, 7297, 7144, 6994, 6847, 6703, 6562, 6424,
                          6289, 6157, 6028, 5901, 5777, 5656, 5538, 5422, 5309, 5198, 5089, 4983, 4880, 4778, 4679, 4583, 4488, 4395, 4305, 4216, 4130, 4046, 3963, 3882, 3803, 3726, 3651, 3577 };
 #elif defined(B3530)
  /*         B25/100: 3530         */
  uint16_t m_adc[151] = { 31484, 31421, 31355, 31286, 31215, 31140, 31062, 30980, 30896, 30807, 30715, 30620, 30521, 30417, 30310, 30199, 30084, 29965, 29842, 29714, 29582, 29446, 29305, 29160,
                          29010, 28856, 28697, 28534, 28366, 28193, 28016, 27834, 27648, 27457, 27261, 27061, 26857, 26648, 26435, 26217, 25996, 25770, 25540, 25307, 25069, 24828, 24583, 24335,
                          24084, 23829, 23571, 23311, 23048, 22782, 22514, 22244, 21971, 21697, 21422, 21144, 20866, 20586, 20306, 20024, 19743, 19461, 19178, 18896, 18614, 18332, 18051, 17770,
                          17491, 17212, 16935, 16659, 16384, 16111, 15840, 15571, 15304, 15039, 14776, 14516, 14258, 14003, 13750, 13500, 13253, 13009, 12767, 12529, 12294, 12062, 11833, 11607,
                          11385, 11166, 10950, 10737, 10528, 10322, 10120, 9920, 9725, 9532, 9343, 9157, 8974, 8795, 8619, 8446, 8276, 8110, 7947, 7786, 7629, 7475, 7324, 7176, 7031, 6889, 6750,
                          6613, 6479, 6349, 6220, 6095, 5972, 5851, 5733, 5618, 5505, 5394, 5286, 5180, 5077, 4975, 4876, 4779, 4684, 4591, 4500, 4411, 4324, 4239, 4156, 4074, 3994, 3916, 3840 };
 #elif defined(B3492)
  /*         B25/100: 3492         */
  uint16_t m_adc[151] = { 31456, 31392, 31326, 31256, 31184, 31108, 31029, 30947, 30862, 30773, 30680, 30584, 30484, 30381, 30273, 30162, 30046, 29927, 29803, 29675, 29543, 29406, 29266, 29121,
                          28971, 28817, 28659, 28496, 28328, 28156, 27980, 27799, 27613, 27423, 27229, 27030, 26827, 26620, 26408, 26192, 25972, 25749, 25521, 25289, 25054, 24815, 24573, 24327,
                          24078, 23826, 23571, 23314, 23054, 22791, 22526, 22259, 21989, 21719, 21446, 21172, 20897, 20621, 20343, 20066, 19787, 19508, 19229, 18951, 18672, 18393, 18115, 17838,
                          17562, 17286, 17012, 16739, 16468, 16198, 15929, 15663, 15399, 15136, 14876, 14618, 14363, 14110, 13859, 13611, 13366, 13124, 12885, 12648, 12415, 12184, 11957, 11733,
                          11512, 11294, 11079, 10867, 10659, 10454, 10252, 10054, 9858, 9666, 9478, 9292, 9110, 8931, 8755, 8582, 8413, 8246, 8083, 7922, 7765, 7611, 7460, 7311, 7166, 7023, 6883,
                          6746, 6612, 6481, 6352, 6225, 6102, 5981, 5862, 5746, 5632, 5521, 5412, 5305, 5200, 5098, 4998, 4900, 4804, 4710, 4618, 4528, 4440, 4354, 4269, 4187, 4106, 4027, 3950 };
 #else
  /*         B25/100: 3380         */
  uint16_t m_adc[151] = { 31370, 31304, 31235, 31163, 31088, 31011, 30930, 30845, 30758, 30667, 30573, 30475, 30373, 30268, 30159, 30047, 29930, 29810, 29685, 29557, 29425, 29288, 29148, 29003,
                          28854, 28701, 28543, 28382, 28216, 28046, 27872, 27693, 27511, 27324, 27133, 26938, 26739, 26536, 26329, 26118, 25903, 25685, 25463, 25238, 25009, 24777, 24542, 24304,
                          24062, 23818, 23571, 23322, 23070, 22816, 22560, 22302, 22042, 21781, 21518, 21254, 20988, 20722, 20454, 20186, 19918, 19649, 19380, 19111, 18842, 18573, 18305, 18038,
                          17771, 17505, 17240, 16976, 16713, 16452, 16192, 15934, 15678, 15423, 15171, 14920, 14672, 14426, 14182, 13941, 13702, 13466, 13232, 13001, 12773, 12548, 12325, 12105,
                          11888, 11674, 11463, 11255, 11050, 10847, 10648, 10452, 10259, 10069, 9882, 9698, 9517, 9339, 9164, 8992, 8822, 8656, 8493, 8333, 8175, 8020, 7868, 7719, 7573, 7429, 7288,
                          7150, 7015, 6881, 6751, 6623, 6497, 6374, 6254, 6135, 6020, 5906, 5795, 5685, 5578, 5474, 5371, 5270, 5172, 5075, 4980, 4888, 4797, 4708, 4621, 4535, 4451, 4370, 4289 };
 #endif

 //
//=================================================ФУНКЦИИ===================================================================
static void writeRegister(uint8_t i2cAddress, uint8_t reg, uint16_t value) {  // Запись регистров АЦП
  Wire.beginTransmission(i2cAddress);
  Wire.write((uint8_t)reg);
  Wire.write((uint8_t)(value >> 8));
  Wire.write((uint8_t)(value & 0xFF));
  Wire.endTransmission();
}
static uint16_t r_EAdregister(uint8_t i2cAddress, uint8_t reg) {              // Чтение регистров АЦП
  Wire.beginTransmission(i2cAddress);
  Wire.write((uint8_t)reg);
  Wire.endTransmission();
  Wire.requestFrom(i2cAddress, (uint8_t)2);
  return ((Wire.read() << 8) | Wire.read());
}
uint16_t readADS(uint8_t channel, uint8_t cnt) {                              // Чтение усредненных из количества cnt значений канала АЦП № channel
  if (channel > 7 || cnt == 0) return 0;
  uint8_t ads_i2cAddress = 0;
  uint16_t config = 0b1000010111100011;
  switch (channel) {
    case (0):
      config |= ADS1115_REG_CONFIG_MUX_SINGLE_0;
      ads_i2cAddress = ADS_I2CADDR_1;
      break;
    case (1):
      config |= ADS1115_REG_CONFIG_MUX_SINGLE_1;
      ads_i2cAddress = ADS_I2CADDR_1;
      break;
    case (2):
      config |= ADS1115_REG_CONFIG_MUX_SINGLE_2;
      ads_i2cAddress = ADS_I2CADDR_1;
      break;
    case (3):
      config |= ADS1115_REG_CONFIG_MUX_SINGLE_3;
      ads_i2cAddress = ADS_I2CADDR_1;
      break;
    case (4):
      config |= ADS1115_REG_CONFIG_MUX_SINGLE_0;
      ads_i2cAddress = ADS_I2CADDR_2;
      break;
    case (5):
      config |= ADS1115_REG_CONFIG_MUX_SINGLE_1;
      ads_i2cAddress = ADS_I2CADDR_2;
      break;
    case (6):
      config |= ADS1115_REG_CONFIG_MUX_SINGLE_2;
      ads_i2cAddress = ADS_I2CADDR_2;
      break;
    case (7):
      config |= ADS1115_REG_CONFIG_MUX_SINGLE_3;
      ads_i2cAddress = ADS_I2CADDR_2;
      break;
  }
  uint32_t summ = 0;
  for (uint8_t i = 0; i < cnt; i++) {
    writeRegister(ads_i2cAddress, ADS1115_REG_POINTER_CONFIG, config);  // Write config register to the ADC
    delayMicroseconds(1200);
    summ += r_EAdregister(ads_i2cAddress, ADS1115_REG_POINTER_CONVERT);
  }
  return (uint16_t)(summ / cnt);
}
int32_t computeTemp_15bit(uint16_t adcRez) {                                  // Перевод значения с АЦП в температуру

  if (adcRez > m_adc[0]) return -55000;
  else if (adcRez < m_adc[150]) return 125000;
  else {
    for (int32_t i = 0; i < 150; i++) {
      if (adcRez <= m_adc[i] && adcRez > m_adc[i + 1]) {
        int32_t ra = (uint32_t)(m_adc[i] - adcRez) * 1000 / (m_adc[i] - m_adc[i + 1]);
        return ((i - 25) * 1000 + ra);
      }
    }
  }
  return 0;
}
uint16_t G_to_alc(uint16_t G) {                                               // Перевод плотности *10000 в объёмные проценты спирта
   uint16_t G_alc[51] = {9982, 9945, 9910, 9878, 9848, 9819, 9791, 9764, 9739, 9713, 9686, 9659, 9631, 9602, 9571, 9538, 9504, 9468, 9431, 9392,
                         9352, 9311, 9269, 9226, 9182, 9138, 9094, 9049, 9003, 8957, 8911, 8865, 8818, 8771, 8724, 8677, 8629, 8581, 8532, 8484,
                         8434, 8385, 8335, 8284, 8232, 8180, 8126, 8071, 8014, 7955, 7893};
  if (G > G_alc[0]) return 0;
  else if (G < G_alc[50]) return 1000;
  else {
    for (int32_t i = 0; i < 50; i++) {
      if (G <= G_alc[i] && G > G_alc[i + 1]) return((i*20) + ((G_alc[i] - G)*20) / (G_alc[i] - G_alc[i + 1]));
    }
  }
}
uint16_t Alc_to_G(uint16_t Alc) {                                                // перевод объёмных процентов спирта *100 в плотность *10000
   uint16_t alc_G[39] = {0, 303, 640, 1014, 1416, 1844, 2250, 2632, 2976, 3294, 3595, 3875, 4146, 4409, 4664, 4914, 5164, 5409, 5648, 5887,
                         6126, 6362, 6596, 6830, 7063, 7292, 7518, 7746, 7968, 8192, 8412, 8627, 8838, 9048, 9251, 9449, 9641, 9826, 10000};
  if (Alc > 9999) return 7893;
  else if (Alc == 0 ) return 9982;
  else {
    for (int32_t i = 0; i < 38; i++) {
      if (Alc >= alc_G[i] && Alc < alc_G[i + 1]) return(9982-i*55 - (uint32_t)(((alc_G[i] - Alc)*55) / (alc_G[i] - alc_G[i + 1])));
    }
  }
}
uint16_t T_to_ADS(float t) {                                                  // Вычисление АДС в зависимости от температуры
  float Rt=R10 * 1000 * exp((1/(t+273.15)-1/298.15)*B25);
  float Rp=1/(1/Rt+1/(R10*1000));
  uint16_t ADS=round(((U33/(R62*1000+Rp))*Rp)/Uref *32768);
  return(ADS);
}
void ADS_Construct() {                                                        // Конструктор характеристики термисторов
  for (int32_t i = 0; i < 150; i++) {
   m_adc[i]=T_to_ADS(i-25);
  }
}
void EEPROM_Init() {                                                          // Инициализация переменных из/в EEPROM
  if (EEPROM[0]==EepromKey) {           
    EEPROM.get(KTemp_2_EAdr,KTemp_2); EEPROM.get(BaseTemp_2_EAdr,BaseTemp_2); EEPROM.get(PressureBaseADS_EAdr,PressureBaseADS); EEPROM.get(PressureQ_EAdr,PressureQ);
    EEPROM.get(KTemp_3_EAdr,KTemp_3); EEPROM.get(BaseTemp_3_EAdr,BaseTemp_3); EEPROM.get(dPress_3_EAdr,dPress_3); EEPROM.get(HX710B_Mult_EAdr,HX710B_Mult);
    EEPROM.get(KTemp_1_EAdr,KTemp_1); EEPROM.get(BaseTemp_1_EAdr,BaseTemp_1); EEPROM.get(dPress_1_EAdr,dPress_1);
    EEPROM.get(U33_EAdr,U33); EEPROM.get(Uref_EAdr,Uref); EEPROM.get(R62_EAdr,R62); EEPROM.get(R10_EAdr,R10);  EEPROM.get(B25_EAdr,B25); 
    EEPROM.get(m_adc_EAdr,m_adc);
    EEPROM.get(N_dPressure_EAdr,N_dPressure); EEPROM.get(k_Alc_T_EAdr,k_Alc_T);  EEPROM.get(k_Alc_EAdr,k_Alc);
   } else {
    EEPROM[0]=EepromKey;
    EEPROM.put(KTemp_2_EAdr,KTemp_2); EEPROM.put(BaseTemp_2_EAdr,BaseTemp_2); EEPROM.put(PressureBaseADS_EAdr,PressureBaseADS); EEPROM.put(PressureQ_EAdr,PressureQ);
    EEPROM.put(KTemp_3_EAdr,KTemp_3); EEPROM.put(BaseTemp_3_EAdr,BaseTemp_3); EEPROM.put(dPress_3_EAdr,dPress_3); EEPROM.put(HX710B_Mult_EAdr,HX710B_Mult);
    EEPROM.put(KTemp_1_EAdr,KTemp_1); EEPROM.put(BaseTemp_1_EAdr,BaseTemp_1); EEPROM.put(dPress_1_EAdr,dPress_1);
    EEPROM.put(U33_EAdr,U33); EEPROM.put(Uref_EAdr,Uref); EEPROM.put(R62_EAdr,R62); EEPROM.put(R10_EAdr,R10);  EEPROM.put(B25_EAdr,B25);
    EEPROM.put(m_adc_EAdr,m_adc);
    EEPROM.put(N_dPressure_EAdr,N_dPressure); EEPROM.put(k_Alc_T_EAdr,k_Alc_T); EEPROM.put(k_Alc_EAdr,k_Alc);
  }
}
void ReadPressure() {                                                         // Чтение датчиков давления и запись их в 1Ware хаб, если есть подключение
  if (Pressure_enable[1]) {                                  // Чтение датчика давления I2C
    XGZP6897D.readSensor(temperature[1], pressure[1]); 
    dPt_1 = ((float)temperature[1] - BaseTemp_1) * KTemp_1;
    pressure[1]= (float)pressure[1] * 0.00750063755419211 - dPress_1- dPt_1;
    if (Pressure_enable[0]==1) Temp[0] =pressure[1];
  }  
  if (Pressure_enable[2]) {                                  // Чтение датчика давления на 8 канале АЦП
    ADSt=(float)readADS(7, 16);
    pressure[2] = ((ADSt - PressureBaseADS) * PressureQ);             //чтение датчика и перевод значения в мм.рт.ст
                                                                                      //применение поправки и температурной компенсации (эмпирически)
    Temp[6] = (float)computeTemp_15bit(readADS(6, 4)) / 1000;                         // чтение температуры 7 датчика
    dPt_2 = ((float)Temp[6] - BaseTemp_2) * KTemp_2;                                  // расчет поправки термокомпенсации если используется
    pressure[2]= ((float)pressure[2] - (float)dPress_2) - dPt_2;
    if (Pressure_enable[0]==2) Temp[0] = pressure[2];
  }  
  if (Pressure_enable[3]) {// Чтение датчика давления на АЦП HX710B
    Temp[6] = (float)computeTemp_15bit(readADS(6, 4)) / 1000;                                         // чтение температуры 7 датчика
    dPt_3 = ((float)Temp[6] - BaseTemp_3) * KTemp_3;                                                  // расчет поправки термокомпенсации если используется
    if (HX710B_Obj.is_ready()) pressure[3] = (float)HX710B_Obj.raw2mmHg((int32_t)HX710B_Obj.get_value(4)*HX710B_Mult)-(float)dPress_3-dPt_3;  //чтение датчика, перевод значения в мм.рт.ст, умножение на коэф вранья
                                                                                                      //применение поправки и температурной компенсации (эмпирически)
                                                  
    if (Pressure_enable[0]==3) Temp[0] = (float)pressure[3]; 
  }  
  if (OneWireConnectDetected) {                              // Запись значения давления в виде температуры по 1Ware
    int16_t tempCompute = int16_t(Temp[0] * 256);  
    ds18bP.scratchpad[3] = tempCompute >> 8;
    ds18bP.scratchpad[2] = tempCompute & 0xff;
    ds18bP.setTemperature(Temp[0]);
  }
}
void RotatePSensor() {                                                        // Смена активного сенсора давления
    if (digitalRead(BtnUp) == LOW)  { // Меняем датчики давления по кругу по нажатию BtnUp
     switch (Pressure_enable[0]) { 
        case 1: {
        if (Pressure_enable[2]==1) {Pressure_enable[0]=2; break; }
        if (Pressure_enable[3]==1) {Pressure_enable[0]=3; break; }
        }
        case 2: {
        if (Pressure_enable[3]==1) {Pressure_enable[0]=3; break; }
        if (Pressure_enable[1]==1) {Pressure_enable[0]=1; break; }
        }
        case 3: {
        if (Pressure_enable[1]==1) {Pressure_enable[0]=1; break; }
        if (Pressure_enable[2]==1) {Pressure_enable[0]=2; break; }
        }
       }

       LD.clearDisplay();
    } 

} 
bool EnterPressed(){                                                          // Нажатие Enter с контролем последующего отпускания
 if (digitalRead(BtnEnter) == LOW) 
        { if (BtnEnterFlg == false) {BtnEnterFlg = true; return(true); 
		                     } else return(false);
   } else 	{ BtnEnterFlg = false; return(false); }
}
bool SelectPressed(){                                                         // Нажатие Select с контролем последующего отпускания
 if (digitalRead(BtnSel) == LOW) 
        { if (BtnSelFlg == false) {BtnSelFlg = true; return(true); 
		                     } else return(false);
   } else 	{ BtnSelFlg = false; return(false); }
}
void Caption(uint8_t Cap, uint8_t Str){                                       // Вывод сообщений на дисплей
  switch (Cap) {                                                              // (для экономии памяти ардуины, первое число в комментариях - количество вызовов)
      case 1: LD.printString_6x8(F("Настройка д. давлен."), 1, Str); break; //1 Cap_NastrDD = 1;
      case 2: LD.printString_6x8(F("Датчик XGZP6897D I2C"), 1, Str); break; //3 Cap_XGZP6897D = 2;
      case 3: LD.printString_6x8(F("Датчик MPX5010DP АЦП"), 1, Str); break; //3 Cap_MPX5010DP = 3;
      case 4: LD.printString_6x8(F("Датчик на АЦП HX710B"), 1, Str); break; //3 Cap_HX710B = 4;
      case 5: LD.printString_6x8(F("Настройка термист."), 1, Str); break; //12 Cap_NastrNTC = 5;
      case 6: LD.printString_6x8(F("Настройка э.попугая."), 1, Str); break; //4 Cap_NastrEP = 6;
     
      case 21: LD.printString_6x8(F("Настр. базового ADS "), 1, Str); break; //1 Cap_NastrBasADS = 21;
      case 22: LD.printString_6x8(F("Настройка смещения 0"), 1, Str); break; //2 Cap_NastrOffset0 = 22;
      case 23: LD.printString_6x8(F("Настр.коэф.термокомп"), 1, Str); break; //3 Cap_NastrKtk = 23;
      case 25: LD.printString_6x8(F("Расчет В25/100"), 1, Str); break; //5 Cap_RaschB25 = 25;
      case 26: LD.printString_6x8(F("B25 расчитанный/тек."), 1, Str); break; //1 Cap_B25Rasch_Current = 26;
      case 27: LD.printString_6x8(F("N датчика давления"), 1, Str); break; //2 Cap_N_DP = 27;
      case 28: LD.printString_6x8(F("Корр. по t. 0-выкл"), 1, Str); break; //1 Cap_K_cor_po_t = 28;
      case 30: LD.printString_6x8(F("Настройка не треб."), 1, Str); break; //1 Cap_NastrNoNeed = 30;
      case 31: LD.printString_6x8(F("Цена разр.АЦП, квант"), 1, Str); break; //1 Cap_Quant = 31;
      case 32: LD.printString_6x8(F("Установка множителя"), 1, Str); break; //1 Cap_SetMult = 32;
      case 33: LD.printString_6x8(F("Сброс всех настроек?"), 1, Str); break; //1 Cap_EEPROM_0 = 33
      
      case 51: LD.printString_6x8(F("Подайте 0 мм.рт.ст. "), 1, Str); break; //3 Cap_0mmg = 51;
      case 52: LD.printString_6x8(F("Подайте 30 мм.рт.ст."), 1, Str); break; //1 Cap_30mmg = 52;
      case 53: LD.printString_6x8(F("Подайте 50 мм.рт.ст."), 1, Str); break; //1 Cap_50mmg = 53;
      case 54: LD.printString_6x8(F("Ent-Начать,Sel-Проп."), 1, Str); break; //4 Cap_NextQ = 54;
      case 56: LD.printString_6x8(F("Напряжение 3.3 В"), 1, Str); break; //1 Cap_U33 = 56;
      case 57: LD.printString_6x8(F("Референс. напряжение"), 1, Str); break; //1 Cap_Uref = 57;
      case 60: LD.printString_6x8(F("Залейте раствор, %"), 1, Str); break; //1 Cap_Fill_Sort = 60;
      case 63: LD.printString_6x8(F("Нагрейте датчик 36.6"), 1, Str); break; //3 Cap_Burn_P_36_6 = 63;
      case 64: LD.printString_6x8(F("Сохранить? (Enter)"), 1, Str); break; //2 Cap_SaveQ = 64;
      case 65: LD.printString_6x8(F("Расч.кривую термист?"), 1, Str); break; //1 Cap_NextCalc = 65;
      case 66: LD.printString_6x8(F("Резистор 6.2 кОм"), 1, Str); break; //1 Cap_R_62kOm = 66;
      case 67: LD.printString_6x8(F("Резистор 10 кОм"), 1, Str); break; //1 Cap_R_10kOm = 67;
      
      case 81: LD.printString_6x8(F("Зап.-Ent. След.-Sel"), 1, Str); break; //21 Menu_Write_Next = 81;
      case 82: LD.printString_6x8(F(" Да -Ent. След.-Sel"), 1, Str); break; //2 Menu_Yes_Next = 82;
      case 83: LD.printString_6x8(F("Зап-Ent.След-Sel,+/-"), 1, Str); break; //5 Menu_Write_Next_PgUp_PgDn = 83;
      case 84: LD.printString_6x8(F(" Up (+),    Dwn (-) "), 1, Str); break; //6 Menu_PgUp_PgDn = 84;
      case 85: LD.printString_6x8(F(" След.-Sel"), 1, Str); break; //4 Menu_Next = 85;
      case 86: LD.printString_6x8(F("Ent.-Настр.Sel-Верн."), 1, Str); break; //1 Menu_Nastr = 86;
        }        
}
void PrintPar(char Name[4], uint8_t Str, uint8_t r, float Par){               // Вывод на дисплей переменной
 if (Rec) {LD.printString_12x16(Name, 0, Str); } else  {LD.printString_12x16(F("Rec"), 0, Str); Rec=1;} // печатаем название, если перед этим была запись в EEPROM, печатаем 1 раз Rec
 dtostrf((float)Par, 6, r, outstr); 
 LD.printString_12x16(outstr, 48, Str);
}
bool Select(){                                                                // Переход на следующий экран по Select с очисткой экрана
   if (SelectPressed()) {          // Переключение на следующий экран по кнопке BtnSel
       DispMode++; 
       LD.clearDisplay();  
       return(true);
       }   
  return(false);
}
void EnterJump(uint8_t disp){                                                 // переход по Enter на экран № disp
 if (EnterPressed()) {DispMode=disp; LD.clearDisplay();}
}
void InputPar(float& Par, float dPar) {                                       // Диалог ввода параметра
	 if (digitalRead(BtnUp) == LOW)  Par += dPar;  // Коррекция параметра кнопками
   if (digitalRead(BtnDwn) == LOW) Par -= dPar;
}
void PrintTemp(uint8_t i, char Name[4], uint8_t Str){                         // Вывод на дисплей температуры № i
  LD.printString_12x16(Name, 0, Str);
  if (ntcEn[i]) {dtostrf((float)Temp[i], 6, 2, outstr); LD.printString_12x16(outstr, 48, Str);} else LD.printString_12x16(F("----"), 60, Str);
}
void disp() {                                                                 // Вывод на дисплей страниц отображения и настроек 
 //-----------------------------------------Константы для диалогов-------------------------------------
      const uint8_t //Номера сообщений диалога
      Cap_NastrDD = 1, //Настройка д. давлен.
      Cap_XGZP6897D = 2, //Датчик XGZP6897D I2C
      Cap_MPX5010DP = 3, //Датчик MPX5010DP АЦП
      Cap_HX710B = 4, //Датчик на АЦП HX710B
      Cap_NastrNTC = 5, //Настройка термист.
      Cap_NastrEP = 6, //Настройка э.попугая.
     
      Cap_NastrBasADS = 21, //Настр. базового ADS 
      Cap_NastrOffset0 = 22, //Настройка смещения 0
      Cap_NastrKtk = 23, //Настр.коэф.термокомп
      Cap_RaschB25 = 25, //Расчет В25/100
      Cap_B25Rasch_Current = 26, //B25 расчитанный/тек.
      Cap_N_DP = 27, //N датчика давления
      Cap_K_cor_po_t = 28, //Высота столба, см
      Cap_NastrNoNeed = 30, //Настройка не треб.
      Cap_Quant = 31, //Цена разр.АЦП, квант
      Cap_SetMult = 32, //Установка множителя
      Cap_EEPROM_0 = 33, //Сброс настроек?

      Cap_0mmg = 51, //Подайте 0 мм.рт.ст. 
      Cap_30mmg = 52, //Подайте 30 мм.рт.ст.
      Cap_50mmg = 53, //Подайте 50 мм.рт.ст.
      Cap_NextQ = 54, //Ent-Начать,Sel-Проп.
      Cap_U33 = 56, //Напряжение 3.3 В
      Cap_Uref = 57, //Референс. напряжение
      Cap_Fill_Sort = 60, //Залейте раствор, %
      Cap_Burn_P_36_6 = 63, //Нагрейте датчик 36.6
      Cap_SaveQ = 64, //Сохранить? (Enter)
      Cap_NextCalc = 65, //Расч.кривую термист?
      Cap_R_62kOm = 66, //Резистор 6.2 кОм
      Cap_R_10kOm = 67, //Резистор 10 кОм
      
      Menu_Write_Next = 81, //Зап.-Ent. След.-Sel
      Menu_Yes_Next = 82, // Да -Ent. След.-Sel
      Menu_Write_Next_PgUp_PgDn = 83, //Зап-Ent.След-Sel,+/-
      Menu_PgUp_PgDn = 84, // Up (+),    Dwn (-) 
      Menu_Next = 85, // След.-Sel
      Menu_Nastr = 86; // Ent.-Настр.Sel-Верн.
 switch (DispMode) {                                           // Экраны дисплея
  case 0: {                             // Экран Основной
    RotatePSensor();                             // Меняем датчики давления по кругу по нажатию BtnUp
    switch (Pressure_enable[0]) {
      case 0: PrintTemp(0, "Тв= ", 0); break;    
      case 1: PrintTemp(0, "Pк1 ", 0); break;
      case 2: PrintTemp(0, "Pк2 ", 0); break;
      case 3: PrintTemp(0, "Pк3 ", 0); 
    }
    PrintTemp(1, "Tп= ", 2); 
    PrintTemp(2, "Tц= ", 4);
    PrintTemp(3, "Tк= ", 6);
    if (EnterPressed()) {        // Фиксация нуля текущего датчика давления понажатию BtnEnter без записи в EEPROM
      switch (Pressure_enable[0]) {
      case 1: dPress_1 = pressure[1] + dPress_1; LD.clearDisplay(); break;         // Убираем дрейф нуля датчика давления I2C
      case 2: dPress_2 = pressure[2] + dPress_2; LD.clearDisplay(); break;         // Убираем дрейф нуля датчика давления на 8 канале АЦП
      case 3: dPress_3 = pressure[3] + dPress_3; LD.clearDisplay(); break;         // Убираем дрейф нуля датчика давления на АЦП HX710B
      }
    }
  } Select(); break;
  case 1: {                             // Экран температуры с 4 по 7
    PrintTemp(4, "Тв= ", 0);
    PrintTemp(5, "TСА ", 2); 
    if (N_dPressure) {
      if (pressure[N_dPressure]>5) 
       {Alc=(float)G_to_alc((uint16_t)(k_Alc*pressure[N_dPressure]))/10;    // Рассчет объемного содержания спирта, %
       Alc_T=Alc+(20-Temp[6])*k_Alc_T;                                         // Простенькая и совсем не точная коррекция по температуре
       PrintPar("Alc%",4,1,Alc_T);} else LD.printString_12x16(F("Alc%  --- "), 0, 4);
      } else PrintTemp(6, "Тep ", 4);
    //PrintTemp(7, "Тtk ", 6);
    Caption(Menu_Nastr,7);
    if (SelectPressed()) {          // Переключение на экран 0 по кнопке BtnSel
     DispMode=0; 
     LD.clearDisplay();  
     } 
    if (EnterPressed()) {      // По нажатию BtnDwn переход на экран настроек давления если есть активный датчик давления, иначе на экран настроек характеристик термисторов
      if (Pressure_enable[0]) DispMode = 2; else DispMode = 7;
      LD.clearDisplay();
      }
    ADSt1 = ADSt; if (Pressure_enable[3]) if (HX710B_Obj.is_ready()) Pressure3Temp = (float)HX710B_Obj.raw2mmHg((int32_t)HX710B_Obj.get_value(4));
  } break; 
  case 2: {                             // Экран настройка датчиков давления запрос пропуска
    B25t=B25;
    RotatePSensor();                             // Меняем датчики давления по кругу по нажатию BtnUp
    Caption(Cap_NastrDD,0); Caption(Cap_NextQ,7); Caption(Cap_N_DP,2);
    PrintPar("   N",4, 0,(float)Pressure_enable[0]);
    EnterJump(4); // переход к датчикам давления
   } if (Select()) DispMode=7;  // Переход к NTC
    break; 
  case 4: {                             // Экран для настройки множителя или кванта датчика давления
    float Qr, Mr;
    RotatePSensor();          // Меняем датчики давления по кругу по нажатию BtnUp, далее по Select
    switch (Pressure_enable[0]) {
      case 1: 
        Caption(Cap_XGZP6897D,0); Caption(Cap_NastrNoNeed,2); Caption(Menu_Next,6); 
        break;
      case 2: 
        Caption(Cap_MPX5010DP,0); Caption(Cap_Quant,1); Caption(Cap_50mmg,2); Caption(Menu_Write_Next,7);
        PrintPar("Q=  ",3, 6,PressureQ); 
        if ((ADSt - ADSt1)>10) PrintPar("Qr= ", 5, 6, (50/(ADSt - ADSt1))); else PrintPar("Qr= ", 5, 6, PressureQ);
        if (EnterPressed()) {
                    PressureQ =(50/(ADSt - ADSt1));
                    EEPROM.put(PressureQ_EAdr,PressureQ); 
                    Rec = 0;
                   }
        break;
      case 3: 
        Caption(Cap_HX710B,0); Caption(Cap_SetMult,1); Caption(Cap_30mmg,2); Caption(Menu_Write_Next,7);
        if (HX710B_Obj.is_ready()) {
          Mr = (float)HX710B_Obj.raw2mmHg((int32_t)HX710B_Obj.get_value(2));
          if (Mr>1) Mr = 30 / (Mr - Pressure3Temp); else Mr = HX710B_Mult;
          }
        PrintPar("M=  ", 3, 2, HX710B_Mult); PrintPar("Мr= ", 5, 2, Mr);
        if (EnterPressed()) {
                     HX710B_Mult = Mr;
                     EEPROM.put(HX710B_Mult_EAdr,HX710B_Mult);
                     Rec = 0;}
        } 
  } Select(); break;
  case 5: {                             // Экран для настройки смещения или базовой АДС датчика давления + запись базовой температуры
   RotatePSensor();          // Меняем датчики давления по кругу по нажатию BtnUp, далее по Select
   switch (Pressure_enable[0]) {
      case 1:
       Caption(Cap_XGZP6897D,0); Caption(Cap_NastrOffset0,1); Caption(Cap_0mmg,2); Caption(Menu_Write_Next,7);
       PrintPar("dP= ", 3, 2, dPress_1); PrintPar("P=  ", 5, 2, pressure[1] + dPt_1);
	     if (EnterPressed()) {
                   dPress_1 = pressure[1] + dPress_1 + dPt_1;
                   EEPROM.put(dPress_1_EAdr,dPress_1);
                   Rec = 0;
                   BaseTemp_1=temperature[1]; EEPROM.put(BaseTemp_1_EAdr,BaseTemp_1);
                   return(0);}
        break;
      case 2:
	     Caption(Cap_MPX5010DP,0); Caption(Cap_NastrBasADS,1); Caption(Cap_0mmg,2); Caption(Menu_Write_Next,7);
       PrintPar("ADS ", 3, 0, ADSt); PrintPar("ADSb", 5, 0, PressureBaseADS);
       if (EnterPressed()) {
                   PressureBaseADS = ADSt; // По нажатию BtnEnter запись АДС
                   EEPROM.put(PressureBaseADS_EAdr,PressureBaseADS);
                   Rec = 0;
                   BaseTemp_2=Temp[6]; EEPROM.put(BaseTemp_2_EAdr,BaseTemp_2);
                   return(0);} 
        break;
      case 3: 
       Caption(Cap_HX710B,0); Caption(Cap_NastrOffset0,1); Caption(Cap_0mmg,2); Caption(Menu_Write_Next,7);
       PrintPar("dP= ", 3, 2, dPress_3); PrintPar("P=  ", 5, 2, pressure[3] + dPt_3);
       if (EnterPressed()) {
                   dPress_3 = pressure[3] + dPress_3 + dPt_3;
                   EEPROM.put(dPress_3_EAdr,dPress_3);
                   Rec = 0;
                   BaseTemp_3=Temp[6]; EEPROM.put(BaseTemp_3_EAdr,BaseTemp_3);
                   return(0);}
    }
  } Select(); break; 
  case 6: {                             // Экран для настройки коэффициента термокомпенсации датчика давления
    switch (Pressure_enable[0]) {
     case 1:   //Для датчика 1
       Caption(Cap_XGZP6897D,0); Caption(Cap_NastrKtk,1); Caption(Cap_Burn_P_36_6,2); Caption(Menu_Write_Next_PgUp_PgDn,7);
       InputPar(KTemp_1, 0.01);
       PrintPar("Ktк=", 3, 2, KTemp_1); PrintPar("P=  ", 5, 2, pressure[1]);
       if (EnterPressed()) {
                   EEPROM.put(KTemp_1_EAdr,KTemp_1);  
                   Rec = 0;
                   }
       break;
     case 2:         //Для датчика на 8 канале АЦП
       Caption(Cap_MPX5010DP,0); Caption(Cap_NastrKtk,1); Caption(Cap_Burn_P_36_6,2); Caption(Menu_Write_Next_PgUp_PgDn,7);
       InputPar(KTemp_2, 0.01);
       PrintPar("Ktк=", 3, 2, KTemp_2); PrintPar("P=  ", 5, 2, pressure[2]);
       if (EnterPressed()) {
                   EEPROM.put(KTemp_2_EAdr,KTemp_2);  
                   Rec = 0;
                   }
       break;
     case 3:   //Для датчика на АЦП HX710B
       Caption(Cap_HX710B,0); Caption(Cap_NastrKtk,1); Caption(Cap_Burn_P_36_6,2); Caption(Menu_Write_Next_PgUp_PgDn,7);
       InputPar(KTemp_3, 0.01); 
       PrintPar("Ktк=", 3, 2, KTemp_3); PrintPar("P=  ", 5, 2, pressure[3]);
       if (EnterPressed()) {
                   EEPROM.put(KTemp_3_EAdr,KTemp_3);
                   Rec = 0;
                   }
    }
  } Select(); break;//  далее по Select
  case 7: {                             // Экран настройка характеристик термисторов запрос рассчета B25
       Caption(Cap_NastrNTC,0); Caption(Cap_RaschB25,2); Caption(Cap_NextQ,6); 
       B25t=B25;
       EnterJump(9); // переход к B25/100  
  } if (Select()) DispMode=14; //  переход к NTC
    break; 
  case 9: {                             // Экран настройка характеристик термисторов настройка T25
       Caption(Cap_NastrNTC,0); Caption(Cap_RaschB25,1); Caption(Menu_Next,6); Caption(Menu_PgUp_PgDn,7);
       InputPar(T25, 0.1);
       PrintPar("T25=", 3, 1, T25); 
  } Select(); break;
  case 10:  {                           // Экран настройка характеристик термисторов настройка R25
       Caption(Cap_NastrNTC,0); Caption(Cap_RaschB25,1); Caption(Menu_Next,6); Caption(Menu_PgUp_PgDn,7);
       InputPar(R25, 0.01);
       PrintPar("R25=", 3, 2, R25); 
  } Select();  break;
  case 11:  {                           // Экран настройка характеристик термисторов настройка T100
       Caption(Cap_NastrNTC,0); Caption(Cap_RaschB25,1); Caption(Menu_Next,6); Caption(Menu_PgUp_PgDn,7);
       InputPar(T100, 0.1);
       PrintPar("T100", 3, 1, T100);
  } Select();  break;
  case 12:  {                           // Экран настройка характеристик термисторов настройка R100
       B25t=round((log(R25*1000)-log(R100*1000))/(1/(T25+273.15)-1/(T100+273.15)));      
       Caption(Cap_NastrNTC,0); Caption(Cap_RaschB25,1); Caption(Menu_Next,6); Caption(Menu_PgUp_PgDn,7);
       InputPar(R100, 0.001);
       PrintPar("R100", 2, 3, R100); PrintPar("В25 ", 4, 0, B25t);
  }  Select(); break;
  case 13:  {                           // Экран Запрос на сохранение В25
         Caption(Cap_NastrNTC,0); Caption(Cap_B25Rasch_Current,1); Caption(Cap_SaveQ,2); Caption(Menu_Write_Next_PgUp_PgDn,7);
         InputPar(B25t, 1);
         PrintPar("B25r", 3, 0, B25t); PrintPar("В25 ", 5, 0, B25);
         if (EnterPressed()) {B25 = B25t; EEPROM.put(B25_EAdr,B25); Rec = 0;}
  } Select();  break;
  case 14:  {                           // Экран настройка характеристик термисторов запрос рассчета кривой 
       Caption(Cap_NastrNTC,0); Caption(Cap_NextCalc,4); Caption(Cap_NextQ,6); 
       EnterJump(16); // переход к NTC
  } if (Select()) DispMode=21; //  переход к попугаю
    break; 
  case 16:  {                           // Экран настройка характеристик термисторов U3.3 
       Caption(Cap_NastrNTC,0); Caption(Cap_U33,1); Caption(Menu_Write_Next,6); Caption(Menu_PgUp_PgDn,7);
       InputPar(U33, 0.01);
       PrintPar("U33=", 3, 2, U33);
       if (EnterPressed()) {EEPROM.put(U33_EAdr,U33); Rec = 0;}
  } Select(); break;
  case 17:  {                           // Экран настройка характеристик термисторов Uref
       Caption(Cap_NastrNTC,0); Caption(Cap_Uref,1); Caption(Menu_Write_Next,6); Caption(Menu_PgUp_PgDn,7);
       InputPar(Uref, 0.001);
       PrintPar("Urf=", 3, 3, Uref);
       if (EnterPressed()) {EEPROM.put(Uref_EAdr,Uref); Rec = 0;}
  } Select(); break;
  case 18:  {                           // Экран настройка характеристик термисторов R10 
       Caption(Cap_NastrNTC,0); Caption(Cap_R_10kOm,1); Caption(Menu_Write_Next,6); Caption(Menu_PgUp_PgDn,7);
       InputPar(R10, 0.001);
       PrintPar("R10=", 3, 3, R10);
       if (EnterPressed()) {EEPROM.put(R10_EAdr,R10); Rec = 0;}
  } Select(); break;
  case 19:  {                           // Экран настройка характеристик термисторов R62
       Caption(Cap_NastrNTC,0); Caption(Cap_R_62kOm,1); Caption(Menu_Write_Next,6); Caption(Menu_PgUp_PgDn,7);
       InputPar(R62, 0.001);
       PrintPar("R62=", 3, 3, R62);
       if (EnterPressed()) {EEPROM.put(R62_EAdr,R62);  Rec = 0;}
  } Select(); break;
  case 20:  {                           // Экран настройка характеристик термисторов запрос сохранения результатов расчёта 
       Caption(Cap_NastrNTC,0); Caption(Cap_SaveQ,1);
       InputPar(Ttemp, 1);
       if (Ttemp>125) Ttemp=-25; if (Ttemp<-25) Ttemp=125;
       PrintPar("T=  ", 2, 1, Ttemp); PrintPar("ADSr", 4, 0, (float)T_to_ADS(Ttemp)); PrintPar("ADS ", 6, 0, (float)m_adc[(round(Ttemp)+25)]);
       if (EnterPressed()) { ADS_Construct(); EEPROM.put(m_adc_EAdr,m_adc);  Rec = 0;};
  } Select();  break;  
  case 21:  {                           // Экран настройка электронного попугая запрос начала 
       Caption(Cap_NastrEP,0); Caption(Cap_NextQ,6); 
       EnterJump(23); // переход к попугаю 
  } if (Select()) DispMode=26;  // переход в сброс EEPROM
    break; 
  case 23:  {                           // Экран настройка электронного попугая номер датчика давления
       Caption(Cap_NastrEP,0); Caption(Cap_N_DP,1); Caption(Menu_Write_Next,7);
       if (digitalRead(BtnUp) == LOW)  N_dPressure++; //!!!!!!!!!!!!!!!!!!!!!!!!!!!!надо переделать
       if (N_dPressure>3) N_dPressure=0; 
       if (!Pressure_enable[N_dPressure]) N_dPressure++; //.......!!!!!!!!!!!!!!
       PrintPar("   N", 4, 0, N_dPressure); 
       if (EnterPressed()) { EEPROM.put(N_dPressure_EAdr,N_dPressure); Rec = 0;};
  } Select(); break;
  case 24:  {                           // Экран настройка электронного попугая включение/отключение термокоррекции
       Caption(Cap_NastrEP,0); Caption(Cap_K_cor_po_t,1); Caption(Menu_Write_Next,7);
       InputPar(k_Alc_T, 0.3);
       if (k_Alc_T<-0.1) k_Alc_T=0.3;
       if (k_Alc_T>0.4) k_Alc_T=0.0;
       PrintPar("  Kt", 4, 1, k_Alc_T);
       if (EnterPressed()) {EEPROM.put(k_Alc_T_EAdr,k_Alc_T); Rec = 0;}
  } Select(); break;  
  case 25:  {                           // Экран настройка электронного попугая калибровка с сортировкой
       Caption(Cap_NastrEP,0); Caption(Cap_Fill_Sort,1); Caption(Menu_Write_Next_PgUp_PgDn,7);
       InputPar(Alc_tar, 1);
       if (Alc_tar<0) Alc_tar=100;
       if (Alc_tar>100) Alc_tar=0;
       PrintPar("Sor%", 2, 1, Alc_tar);
       if (pressure[N_dPressure]>0.2) {
         PrintPar("kG/P", 5, 1, (Alc_to_G((uint16_t)(Alc_tar*100))/pressure[N_dPressure])); //K_alc
         if (EnterPressed()) { 
          k_Alc=Alc_to_G((uint16_t)(Alc_tar*100))/pressure[N_dPressure]; EEPROM.put(k_Alc_EAdr,k_Alc);  Rec = 0;}
          } 
        else LD.printString_12x16(F(" Нет давл. "), 0, 5); 
  } Select();  break;  
  case 26:  {                           // Сбросить настройки на дефолтные?
   Caption(Cap_EEPROM_0,2); Caption(Menu_Yes_Next,6);
   if (EnterPressed()) { EEPROM[0]=EEPROM[0]+1; asm volatile ("jmp 0x0000"); } // Soft reset
  } if (Select()) DispMode=0;  // переход в начало
    break; 
 }
}
void setup() {                                                                // Инициализация
  wdt_enable(WDTO_2S);                  // Установка таймера watchdog  
  //wdt_disable();
  Wire.begin();                         // Инициализация I2C
  EEPROM_Init();                        // Инициализация переменных из EEPROM
  pinMode(BtnEnter, INPUT_PULLUP);      // Инициализация кнопок, перемычек и светодиода
   pinMode(BtnSel, INPUT_PULLUP);  
   pinMode(BtnUp, INPUT_PULLUP);  
   pinMode(BtnDwn, INPUT_PULLUP);
   pinMode(7, INPUT_PULLUP); // Пины перемычек для определения наличия датчиков давления 040DR1 и MPX50DP 
   pinMode(8, INPUT_PULLUP); 
   pinMode(pin_led, OUTPUT); digitalWrite(pin_led, 1); // Светодиод на ардуине
  LD.init();                        // Инициализация OLED дисплея
   LD.clearDisplay();  // Очищаем, иначе некорректно работает для дисплеев на SH1106 (косяк библиотеки)
 #if defined(SERIAL_DEBUG) || defined(SERIAL_TEST_NTC) // Инициализация СОМ порта
   Serial.begin(115200);
   millisConvert = millis();
 #endif
  if (digitalRead(BtnEnter) == LOW) {  // Если кнопка зажата включаем режим измерения сопротивлений
    Mode_R = 1;
    LD.clearDisplay();
    return (0);
  }
  if (digitalRead(7) == LOW) {         // Если D7 ардуины замкнут на массу значит подключен датчик 040DR1 или т.п. с АЦП HX710B
    Pressure_enable[0] = 3;
    Pressure_enable[3] = 1;
    HX710B_Obj.begin(DOUT, SCLK);
    HX710B_Obj.set_scale(1);
    HX710B_Obj.set_offset(0);
  }  
  if (digitalRead(8) == LOW) {         // Если D8 ардуины замкнут на массу значит подключен датчик  MPX50DP или т.п.
    Pressure_enable[0] = 2;  
    Pressure_enable[2] = 1;
  }
  if (XGZP6897D.begin()) {              // Инициализация датчика XGZP6897D
    Pressure_enable[0] = 1;  
    Pressure_enable[1] = 1;
  }
  if (Pressure_enable[0]) {            // Добавляем в хаб 1Ware датчик давления
    hub.attach(ds18bP);
    ds18bP.setTemperature((float)0.0);
    ntcEn[0] = 1;
   } else { // если датчика давления нет заменяем его вывод на дисплей на 4 датчик температуры
    ntcEn[0] = 0;
  }  
  if (readADS(0, 1) < ADS_Trg) {       // Определение подключенных термисторов и инициализация их адресов по 1Ware
     hub.attach(ds18b1);
     ntcEn[1] = 1;
     ds18b1.setTemperature((float)25.0);
   } else ntcEn[1] = 0;
   if (readADS(1, 1) < ADS_Trg) {
     hub.attach(ds18b2);
     ntcEn[2] = 1;
     ds18b2.setTemperature((float)25.0);
   } else ntcEn[2] = 0;
   if (readADS(2, 1) < ADS_Trg) {
     hub.attach(ds18b3);
     ntcEn[3] = 1;
     ds18b3.setTemperature((float)25.0);
   } else ntcEn[3] = 0;
   if (readADS(3, 1) < ADS_Trg) {
     hub.attach(ds18b4);
     ntcEn[4] = 1;
     ds18b4.setTemperature((float)25.0);
   } else ntcEn[4] = 0;
   if (readADS(4, 1) < ADS_Trg) {
     hub.attach(ds18b5);
     ntcEn[5] = 1;
     ds18b5.setTemperature((float)25.0);
   } else ntcEn[5] = 0;
   if (readADS(5, 1) < ADS_Trg) {  // Выделен под поправку электронного попугая
     //hub.attach(ds18b6);
     ntcEn[6] = 1;
     //ds18b6.setTemperature((float)25.0);
   } else ntcEn[6] = 0;
   if ((readADS(6, 1) < ADS_Trg) /*&& (KTemp_2 == 0)*/) {  // Затействован под температурную компенсацию 
     //hub.attach(ds18b7);
     ntcEn[7] = 1;
     //ds18b7.setTemperature((float)25.0);
   } else ntcEn[7] = 0;
   if ((readADS(7, 1) < ADS_Trg) /*&& (!(Pressure_enable == 2)) && (!(Pressure_enable == 3))*/) {  //Выделен под датчик MPX10DP
     //hub.attach(ds18b8);
     ntcEn[8] = 1;
     //ds18b8.setTemperature((float)0.0);
   } else ntcEn[8] = 0;
   if (!Pressure_enable[0]) ntcEn[0] = ntcEn[4];  // в случае отсутствия датчика давления подмена его на 4 термометр
 //                                       Вывод в СОМ порт информации о подключенных термисторах
  #if defined(SERIAL_DEBUG) || defined(SERIAL_TEST_NTC) 
   uint32_t iT = millis() - millisConvert;
   Serial.print("Инициализация длилась: ");
   Serial.print(iT);
   Serial.println(" мСек.");
   for (int i = 1; i < 9; i++) {
    if (ntcEn[i]) {
      Serial.print("Датчик ");
      Serial.print(i);
      Serial.println(" подключен.");
    }
  }
  #endif
  digitalWrite(pin_led, 0);
}
void loop() {                                                                 // Основной цикл
  if (!Mode_R) {  //Если не режим измерения сопротивления
 #ifndef SERIAL_TEST_NTC

    hub.poll();   // Обработка запросов по 1Wire
    wdt_reset();  // Сброс таймера watchdog

    if (!hub.startConvert) millisConvert = millis() + 50;
    if (hub.startConvert && millisConvert < millis()) {
      if (Pressure_enable[0]) ReadPressure();  // Чтение давления
      uint16_t ad_temp;
      int16_t tempCompute;
      OneWireConnectDetected = true;  //Раз мы сюда попали, значит есть контакт по 1 Ware
      hub.startConvert = false;
      digitalWrite(pin_led, 1);
      for (int i = 1; i < 9; i++) {
        if (ntcEn[i]) {
          ad_temp = readADS(i - 1, 16);                        // Чтение из АЦП канала i-1, среднее из 16 выборок
          Temp[i] = (float)computeTemp_15bit(ad_temp) / 1000;  // запоминаем для последующего вывода на дисплей
          tempCompute = int16_t(Temp[i] * 256);
 #ifdef SERIAL_DEBUG
          Serial.print(ad_temp);
          Serial.print("  Температура датчика ");
          Serial.print(i);
          Serial.print(": ");
          Serial.print(Temp[i], 3);
          Serial.println(" гр.С");
 #endif
          switch (i) {
            case 1:
              ds18b1.scratchpad[3] = tempCompute >> 8;
              ds18b1.scratchpad[2] = tempCompute & 0xff;
              ds18b1.setTemperature(Temp[i]);
              break;
            case 2:
              ds18b2.scratchpad[3] = tempCompute >> 8;
              ds18b2.scratchpad[2] = tempCompute & 0xff;
              ds18b2.setTemperature(Temp[i]);
              break;
            case 3:
              ds18b3.scratchpad[3] = tempCompute >> 8;
              ds18b3.scratchpad[2] = tempCompute & 0xff;
              ds18b3.setTemperature(Temp[i]);
              break;
            case 4:
              ds18b4.scratchpad[3] = tempCompute >> 8;
              ds18b4.scratchpad[2] = tempCompute & 0xff;
              ds18b4.setTemperature(Temp[i]);
              break;
            case 5:
              ds18b5.scratchpad[3] = tempCompute >> 8;
              ds18b5.scratchpad[2] = tempCompute & 0xff;
              ds18b5.setTemperature(Temp[i]);
              break;
              /*case 6:  //Отключено из-за ограничения Самовара в 5 датчиков температуры, здесь каналы с 6 по 8 зарезервированы для электронного попугая, датчика давления и термокомпенсации
               ds18b6.scratchpad[3] = tempCompute >> 8;
               ds18b6.scratchpad[2] = tempCompute & 0xff;
               ds18b6.setTemperature(Temp[i]);
               break;
               case 7:
               ds18b7.scratchpad[3] = tempCompute >> 8;
               ds18b7.scratchpad[2] = tempCompute & 0xff;
               ds18b7.setTemperature(Temp[i]);
               break;
               case 8:
               ds18b8.scratchpad[3] = tempCompute >> 8;
               ds18b8.scratchpad[2] = tempCompute & 0xff;
               ds18b8.setTemperature(Temp[i]);
               break;*/
          }
        }
      }
      if (!Pressure_enable[0]) Temp[0] = Temp[4];  // в случае отсутствия датчика давления подмена его на 4 термометр
      disp();                                   // Вывод на дисплей
      digitalWrite(pin_led, 0);
    }
    if (!OneWireConnectDetected) {  // нет соединения по 1Ware, просто выводим цифры
      // Первые 10 секунд данные выводятся по возможности раз в секунду для того, чтоб не мешать опознать датчики Самовару, затем стабильно раз в секунду.
      if ((((millis() > (timer + 1000)) && (millis() > 10000))) || (((((millis() % 1000) == 0) && (millis() < 10000))))) {
        timer += 1000;
        if (Pressure_enable[0]) ReadPressure();  // Чтение давления
        for (int i = 1; i < 8; i++) {         // читаем температуры в массив
          if (ntcEn[i]) Temp[i] = (float)computeTemp_15bit(readADS(i - 1, 16)) / 1000;
        }
        if (!Pressure_enable[0]) Temp[0] = Temp[4];  // в случае отсутствия датчика давления подмена его на 4 термометр
        disp();                                   // вывод на дисплей
      }
    }
   #else //рудимент для отладки через COM порт, пусть будет
     Serial.println();
     uint32_t tm = millis() + 1000;
     for (int i = 0; i < 8; i++) {
      if (ntcEn[i]) {
        int16_t ad_temp = readADS(i, 16);
        Serial.print("ADC = ");
        Serial.print(ad_temp);
        Serial.print("  |  T");
        Serial.print(i + 1);
        Serial.print(" = ");
        Serial.print((float)computeTemp_15bit(ad_temp) / 1000, 3);
        Serial.print("  |  Time convert (millis) = ");
        Serial.println(millis() + 1000 - tm);
        computeTemp_15bit(ad_temp);
      }
     }

     while (tm > millis()) {
      wdt_reset();  // Сброс таймера watchdog
    }
   #endif

  } else {        // Режим килоомметра
    wdt_reset();  // Сброс таймера watchdog

    if (millis() > (timer + 1000)) {
      timer += 1000;  //раз в секунду
      float Rizm;
      if (digitalRead(BtnSel) == LOW) {  // Меняем канал измерений если нажата кнопка
        ADSCh++;
        if (ADSCh == 8) ADSCh = 0;
      }
      int32_t ADS = (int32_t)readADS(ADSCh, 16);            //Читаем из АЦП
      float Uacp = Uref * ADS / 32768;                      // Напряжение на делителе
      float R10_izm = (Uacp * R62) / (U33 - Uacp);          //Сопротивление параллельных термистора и 10кОм
      if (ADS < 32650) Rizm = 1 / (1 / R10_izm - 1 / R10);  //Сопротивление термистора
      else Rizm = 999;

      LD.printString_12x16(F("ADS"), 0, 0);
      LD.printNumber(long(ADSCh + 1), 36, 0);
      dtostrf(int32_t(ADS), 6, 0, outstr);
      LD.printString_12x16(outstr, 54, 0);

      LD.printString_12x16(F("Uacp"), 0, 2);
      dtostrf(float(Uacp), 6, 3, outstr);
      LD.printString_12x16(outstr, 54, 2);

      LD.printString_12x16(F("RII "), 0, 4);
      dtostrf(float(R10_izm), 6, 3, outstr);
      LD.printString_12x16(outstr, 54, 4);

      LD.printString_12x16(F("Rizm"), 0, 6);
      dtostrf(float(Rizm), 6, 3, outstr);
      if (Rizm > 100) LD.printString_12x16("  -No-", 54, 6);  // Вне диапазона, выводим заглушку
      else LD.printString_12x16(outstr, 54, 6);
    }
  }
}
