// Версия 3.12b от 01.06.25
 #include <Arduino.h>
 #include <Wire.h>
 #include <ESP8266WiFi.h>
 #include <OneWireHub.h>
 #include <DS18B20.h>
 #include <ASOLED_ESP8266.h>     // Библиотека дисплея
 #include <XGZP6897D.h>  // Библиотека датчика давления XGZP6897D
 #include <HX710B.h>     // Библиотека датчика давления на АЦП HX710B
 #include <EEPROM.h>
 #include <ArduinoOTA.h> 
 #include <ESP8266mDNS.h>
 #include <WiFiUdp.h>
 #include <ESPAsyncWebServer.h>
 #include <PubSubClient.h>
 #include <ArduinoJson.h>
 #include "Izm_config.h"
 #include "web_pages.h"
 //------------------------------------------Значения для датчиков давления-------------------------------------------------
 int8_t Pressure_enable[4] = {0, 0, 0 ,0};   // Признаки наличия датчиков давления, вычисляемый, для XGZP6897D = 1 (установится если откликнется по I2C),
                              // для MPX10DP = 2 (установится если сохранено в WEB интерфейсе), для HX710B =3 (установится если сохранено в WEB интерфейсе)
 float pressure[4], temperature[4];  // переменные для чтения датчиков давления
//                                          Датчик XGZP6897D, подключенный к I2C №1
 uint16_t XGZP6897D_k = XGZP6897D_K; //делитель для XGZP6897D
 XGZP6897D XGZP(1);
 // делитель зависит от диапазона датчика, искать в даташите, мой (0 - 10 Pa)
 /*   K value for XGZP6897D. It depend on the pressure range of the sensor.
   Table found in the data sheet from CFSensor.com
    https://cfsensor.com/product-category/i2c-sensor/https://cfsensor.com/product-category/i2c-sensor/
  pressure_range (kPa)   K value
  131<P≤260               32
  65<P≤131                64
  32<P≤65                 128
  16<P≤32                 256
  8<P≤16                  512
  4<P≤8                   1024
  2≤P≤4                   2048
  1≤P<2                   4096
  P<1                     8192
  the K value is selected according to the positive pressure value only,
  like -100～100kPa,the K value is 64.*/ 
 float dPress_1 = 0;         // * Поправка для датчика давления, равна его среднему значению при отсутствии давления и нулевой поправке
 float KTemp_1 = 0;            // * Коэффициент термокомпенсации (наклон кривой), требуется подбор, зависит от выходного диапазона напряжений датчика (при моих экспериментах работает с 0.8-1)
 float BaseTemp_1 = 26.50;  // * Базовая температура для термокомпенсации, можно увидеть на экране настройки датчика давления при реальном давлении =0
  // и после выдержки во включенном состоянии минут 15.
 float dPt_1 = 0;                 // Вычисляемая поправка термокомпенсации

//                                          Датчики подключенные к 8 каналу АЦП (MPX10DP и т.п.) №2
 float ADSt1, ADSt= 23000;  // Переменные для временного хранения
 float PressureBaseADS = 23000;  // * ADS нулевого давления при базовой температуре, узнать величину можно на экране настройки датчика давления при реальном давлении =0 и после выдержки во включенном состоянии минут 15
 float PressureQ = 0.0227273;             // * Квант изменения давления (мм.рт.ст.), на сколько изменится давление при приросте значения от АЦП на 1, для своего датчика надо считать свой, если подключить датчик не напрямую, а через делитель 6.2/10 кОм он будет около 0.3149
 float KTemp_2 = 0.51;            // * Коэффициент термокомпенсации (наклон кривой), требуется подбор, зависит от выходного диапазона напряжений датчика (при моих экспериментах работает с 0.8-1)
 float BaseTemp_2 = 22.70;  // * Базовая температура для термокомпенсации, для MPX10DP и подобных можно увидеть на экране настройки датчика давления при реальном давлении =0
   // и после выдержки во включенном состоянии минут 15.
 float dPress_2 = 0;         // Поправка для датчика давления, равна его среднему значению при отсутствии давления и нулевой поправке,
                                // её можно изменить на свою, но правильнее менять PressureBaseADS 
 float dPt_2 = 0;                 // Вычисляемая поправка термокомпенсации
//                                          Датчик 040DR1 на АЦП HX710B (0-40кПа) и ему подобные, MPS20N0040D-S например №3

 HX710B HX710B_Obj;                // Объект датчика
 float HX710B_Mult = 4.35;         // * Множитель для врунишки чтоб не лезть в библиотеку, характеристика всё равно линейная, ставите 1 и вычисляете при поверке с манометром
 float KTemp_3 = 0.00;             // * Коэффициент термокомпенсации (наклон кривой), требуется подбор, зависит от выходного диапазона напряжений датчика (при моих экспериментах работает с 0.8-1)
 float BaseTemp_3 = 27.57;         // * Базовая температура для термокомпенсации, можно увидеть на экране настройки датчика давления при реальном давлении =0
   // и после выдержки во включенном состоянии минут 15.
 float dPress_3 = 57.41;           // * Поправка для датчика давления, равна его среднему значению при отсутствии давления и нулевой поправке,
                                   // её можно изменить на свою, (-11.46 для моего HX710B)
 float Pressure3Temp, 
       dPt_3 = 0;                  // Вычисляемая поправка термокомпенсации
// -----------------------------------------Электронный попугай------------------------------------------------------------
 uint8_t N_dPressureAlc=0;          // * Номер датчика давления электронного попугая (0-3), 0 - для отключения попугая
 float k_Alc_T=0.3;                 // * Коэффициент для температурной коррекции, 0 - для отключения
 float k_Alc=136;                   // * Коэффициент перевода давления в плотность =G(г/мл)*10000/P (мм.рт.с.)=10*133,322(мм.рт.ст->Па)/(g(9.8 м/с)*h(высота столба жидкости попугая 1 м))
 float Alc=0;                       // Рассчетная крепость 
 float Alc_T=0;                     // Рассчетная крепость с коррекцией по t6  
 float Alc_tar=0;                   // * Крепость раствора для тарирования
// -----------------------------------------Для взаимодействия с пользователем---------------------------------------------
 
 int BtnEnterFlg = 0;
 int BtnSelFlg = 0;
 int8_t DispMode = FIRST_DISP;      // счетчик для для экранов отображения
 ///constexpr uint8_t pin_led{ 13 };  // мигаем светодиодом на ардуине для контроля передачи по 1Ware
 unsigned long timer;              // таймер для отображения при отсутствии соединения по 1Wire
 bool Rec=1;                       // флаг для отображения факта записи значения
 int8_t spk_count = 0;             // счетчик гудков
 int8_t spk_trigger=1;             // триггер гудков
 int8_t spk_on=-1;                  // флаг сигнала
 float T_target=86;           // * исходная температура срабатывания сигнализации
 char outstr[8];            // строка для вывода цифр на экран  
 int8_t spk_max_count = 10;  //* количество гудков 
//------------------------------------------Для считывания значений с АЦП--------------------------------------------------
 float Temp[9];         // массив текущих температур, чтоб не читать по 2 раза за цикл
 #define ADS_Trg 30100  // * Предел для определения подключенных термисторов, в исходнике был 32750, у меня, как оказалось, он должен быть меньше, если оставить \
                       // прежний Самовар из предлагаемых 9 датчиков выбирает себе какие то 5 и глючит, т.к. некоторых в реальности нет.
 #define ADS_I2CADDR_1 (0x48)
 #define ADS_I2CADDR_2 (0x49)
 #define ADS1115_REG_CONFIG_MUX_SINGLE_0 (0x4000)
 #define ADS1115_REG_CONFIG_MUX_SINGLE_1 (0x5000)
 #define ADS1115_REG_CONFIG_MUX_SINGLE_2 (0x6000)
 #define ADS1115_REG_CONFIG_MUX_SINGLE_3 (0x7000)
 #define ADS1115_REG_POINTER_CONVERT (0x00)
 #define ADS1115_REG_POINTER_CONFIG (0x01)

// -----------------------------------------Для передачи данных по 1Ware---------------------------------------------------
 bool OneWireConnectDetected = false;                              // триггер для определения факта соединения по 1Wire
 uint8_t ntcEn[9];                                                 // Массив флагов наличия подключенных датчиков
 auto hub = OneWireHub(pin_onewire);                               // Объект 1Ware хаба
 auto ds18bP = DS18B20(0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22);  // 0x55 Адрес для датчика давления, байт 0x55 вычисляемый в OneWireItem.cpp
                                                                  // в OneWireHub_Config.h изменён параметр #define HUB_SLAVE_LIMIT 9 (было 8)
 auto ds18b1 = DS18B20(0x28, 0x10, 0x55, 0x44, 0x33, 0x22, 0x01);  // 0xD8
 auto ds18b2 = DS18B20(0x28, 0x20, 0x55, 0x44, 0x33, 0x22, 0x02);  // 0xD7
 auto ds18b3 = DS18B20(0x28, 0x30, 0x55, 0x44, 0x33, 0x22, 0x03);  // 0xD2
 auto ds18b4 = DS18B20(0x28, 0x40, 0x55, 0x44, 0x33, 0x22, 0x04);  // 0xC9
 auto ds18b5 = DS18B20(0x28, 0x50, 0x55, 0x44, 0x33, 0x22, 0x05);  // 0xCC
 auto ds18b6 = DS18B20(0x28, 0x60, 0x55, 0x44, 0x33, 0x22, 0x06);  // 0xC3
 auto ds18b7 = DS18B20(0x28, 0x70, 0x55, 0x44, 0x33, 0x22, 0x07);  // 0xC6
 auto ds18b8 = DS18B20(0x28, 0x80, 0x55, 0x44, 0x33, 0x22, 0x08);  // 0xF5

// ---------------------------------------* Включение отладки с выдачей значений в СОМ порт (без передачи данных по 1Ware)-
 //#define SERIAL_DEBUG
 //#define SERIAL_TEST_NTC
 uint32_t millisConvert;  // для рассчета длительности инициализации при отладке

//------------------------------------------Значения для режима килоомметра (включается при зажатой во время загрузки кнопкой действия, либо закороченном первом термисторе) и рассчета характеристик термисторов
 float U33 = 3.33;    // * точное напряжение на пине 3.3 V
 float Uref = 2.047;  // * опорное напряжение, точное напряжение на пине A0 ADS1115 без подключенного делителя
 float R62 = 6.200;   // * точное значение 6.2 кОм резистора
 float R10 = 9.990;   // * точное значение 10 кОм резистора
 float B25 = 3950, B25t = 3950; // * характеристика термисторов
 uint8_t Mode_R = 0;  // триггер режима килоомметра
 uint8_t ADSCh = 0;   // * канал измерений килоомметра
/*--------------------------------------- * С какой характеристикой В(25/100) подключены NTC-термисторы ------------------- */
 float T25 = 25;      // * температура для расчета B25
 float T100 = 100;    // * температура для расчета B25 
 float R25 = 10;      // * точное значение сопротивления терморезистора при 25 гр.Ц, кОм
 float R100 = 0.685;  // * точное значение сопротивления терморезистора при 100 гр.Ц, кОм
 float Ttemp=-25;
 #define ChinaNTC /* B(25/100) = ???? */  //Вариант, когда датчики "китай", либо напряжение питания АЦП отличается от 3,3 В, \
                                         //либо резисторы не совсем 10/6.2 кОм, если абсолютная точность не особо важна \
                                         //можно просто выбрать из тех, что ниже, относительная точность не изменится
 //#define B4300    /* B(25/100) = 4300 */
 //#define B3988    /* B(25/100) = 3988 */
 //#define B3950    /* B(25/100) = 3950 */
 //#define B3625    /* B(25/100) = 3625 */
 //#define B3530    /* B(25/100) = 3530 */
 //#define B3492    /* B(25/100) = 3492 */
 /* NTC-термисторы c характеристикой B(25/100) = 3380, если все остальные закомментированы */
 /*  Таблицы суммарного значения АЦП в зависимости от температуры. От большего значения к меньшему
 *  Для построения таблицы использованы следующие парамертры:
 *    R1(T1): 10кОм(25°С)
 *    Схема включения: Ra подключен к U0, Rb параллельно R1(T1)
 *    Ra/Rb: 6.2кОм/10кОм
 *    Напряжения U0/Uref: 3.3В/2.047В */
 #if defined(ChinaNTC)  // * Эта таблица под мои текущие термисторы, напряжение и делитель \
                       // Таблицу под свои термисторы, Ra/Rb и напряжение питания АЦП можно получить здесь https://aterlux.ru/article/ntcresistor \
                       // какие исходные параметры вставлять читать здесь https://forum.homedistiller.ru/msg.php?id=13976866 и здесь https://forum.homedistiller.ru/msg.php?id=14020829
                       /*         ChinaNTC          */
  uint16_t m_adc[151] = { 32101, 32049, 31993, 31935, 31874, 31810, 31742, 31670, 31595, 31516, 31433, 31346, 31255, 31160, 31060, 30956, 30847, 30732, 30614, 30489, 30360, 30226, 30085, 29940,
                          29789, 29632, 29469, 29300, 29126, 28945, 28758, 28566, 28367, 28162, 27951, 27733, 27510, 27280, 27045, 26803, 26556, 26303, 26044, 25780, 25510, 25235, 24954, 24669,
                          24379, 24085, 23786, 23483, 23176, 22865, 22551, 22234, 21914, 21592, 21267, 20940, 20612, 20282, 19951, 19619, 19286, 18954, 18621, 18288, 17956, 17625, 17296, 16967,
                          16640, 16315, 15992, 15672, 15354, 15039, 14726, 14417, 14112, 13809, 13511, 13216, 12925, 12638, 12355, 12076, 11802, 11532, 11267, 11006, 10749, 10497, 10250, 10007,
                          9769, 9536, 9307, 9083, 8864, 8649, 8439, 8233, 8032, 7835, 7643, 7455, 7272, 7092, 6917, 6746, 6579, 6416, 6257, 6102, 5951, 5803, 5660, 5519,
                          5383, 5249, 5119, 4993, 4870, 4749, 4632, 4518, 4407, 4299, 4194, 4091, 3991, 3894, 3799, 3707, 3617, 3529, 3444, 3361, 3281, 3202, 3125, 3051,
                          2978, 2908, 2839, 2772, 2707, 2643, 2582 };
 #elif defined(B4300)
  /*         B25/100: 4300         */
  uint16_t m_adc[151] = { 31924, 31877, 31827, 31774, 31719, 31659, 31597, 31531, 31461, 31388, 31310, 31229, 31143, 31052, 30958, 30858, 30754, 30644, 30530, 30410, 30284, 30153, 30016, 29873,
                          29724, 29569, 29408, 29241, 29067, 28886, 28699, 28505, 28304, 28097, 27883, 27662, 27434, 27199, 26958, 26710, 26455, 26194, 25926, 25652, 25372, 25086, 24794, 24496,
                          24193, 23885, 23571, 23254, 22931, 22605, 22274, 21941, 21604, 21264, 20921, 20576, 20230, 19881, 19532, 19182, 18831, 18480, 18129, 17779, 17430, 17082, 16735, 16390,
                          16047, 15706, 15368, 15033, 14702, 14373, 14048, 13727, 13410, 13097, 12788, 12484, 12184, 11889, 11599, 11313, 11033, 10758, 10488, 10223, 9963, 9709, 9460, 9216,
                          8977, 8743, 8515, 8292, 8074, 7861, 7653, 7450, 7252, 7059, 6871, 6687, 6508, 6334, 6164, 5999, 5838, 5681, 5529, 5380, 5236, 5095, 4958, 4825, 4696, 4570, 4448, 4329,
                          4214, 4101, 3992, 3886, 3783, 3683, 3585, 3491, 3399, 3310, 3223, 3139, 3057, 2977, 2900, 2825, 2752, 2681, 2612, 2545, 2480, 2417, 2356, 2296, 2238, 2182, 2127 };
 #elif defined(B3988)
  /*         B25/100: 3988         */
  uint16_t m_adc[151] = { 31771, 31718, 31662, 31603, 31541, 31475, 31406, 31334, 31258, 31178, 31095, 31007, 30916, 30820, 30720, 30615, 30505, 30391, 30273, 30149, 30020, 29886, 29747, 29602,
                          29452, 29296, 29135, 28968, 28796, 28617, 28433, 28243, 28048, 27846, 27638, 27425, 27206, 26981, 26750, 26514, 26272, 26024, 25772, 25513, 25250, 24982, 24709, 24431,
                          24149, 23862, 23571, 23277, 22979, 22677, 22372, 22064, 21753, 21440, 21125, 20808, 20489, 20169, 19848, 19525, 19203, 18880, 18557, 18234, 17912, 17590, 17270, 16951,
                          16633, 16317, 16003, 15691, 15381, 15074, 14770, 14469, 14171, 13876, 13584, 13296, 13011, 12731, 12454, 12181, 11912, 11648, 11387, 11131, 10879, 10631, 10388, 10149,
                          9915, 9685, 9459, 9238, 9021, 8808, 8600, 8396, 8197, 8002, 7811, 7624, 7442, 7263, 7089, 6918, 6752, 6589, 6430, 6275, 6124, 5976, 5832, 5691, 5554, 5420, 5289, 5162,
                          5038, 4917, 4798, 4683, 4571, 4462, 4355, 4251, 4150, 4051, 3955, 3862, 3770, 3681, 3595, 3510, 3428, 3348, 3270, 3194, 3120, 3047, 2977, 2908, 2842, 2777, 2713 };
 #elif defined(B3950)
  /*         B25/100: 3950         */
  uint16_t m_adc[151] = { 31751, 31697, 31640, 31580, 31517, 31450, 31381, 31308, 31231, 31151, 31066, 30978, 30886, 30789, 30688, 30583, 30473, 30359, 30239, 30115, 29986, 29852, 29712, 29567,
                          29417, 29262, 29101, 28934, 28762, 28584, 28400, 28211, 28015, 27815, 27608, 27396, 27178, 26954, 26724, 26490, 26249, 26004, 25753, 25496, 25235, 24969, 24698, 24423,
                          24143, 23859, 23571, 23280, 22984, 22686, 22384, 22079, 21772, 21462, 21150, 20836, 20521, 20204, 19886, 19567, 19248, 18928, 18609, 18289, 17970, 17652, 17335, 17019,
                          16704, 16391, 16080, 15771, 15464, 15160, 14859, 14560, 14264, 13971, 13682, 13396, 13114, 12835, 12560, 12289, 12021, 11758, 11499, 11244, 10993, 10747, 10504, 10266,
                          10033, 9803, 9578, 9357, 9141, 8928, 8721, 8517, 8317, 8122, 7931, 7744, 7561, 7383, 7208, 7037, 6870, 6707, 6547, 6391, 6239, 6091, 5946, 5804, 5666, 5531, 5400, 5272,
                          5147, 5024, 4905, 4789, 4676, 4566, 4458, 4353, 4251, 4151, 4054, 3959, 3866, 3776, 3689, 3603, 3520, 3438, 3359, 3282, 3207, 3134, 3062, 2992, 2925, 2858, 2794 };
 #elif defined(B3625)
  /*         B25/100: 3625         */
  uint16_t m_adc[151] = { 31550, 31490, 31426, 31359, 31289, 31217, 31140, 31061, 30978, 30891, 30801, 30707, 30609, 30507, 30402, 30292, 30178, 30059, 29937, 29810, 29678, 29542, 29401, 29256,
                          29106, 28951, 28792, 28627, 28458, 28284, 28105, 27921, 27733, 27540, 27341, 27138, 26931, 26718, 26501, 26280, 26054, 25823, 25589, 25350, 25107, 24860, 24609, 24355,
                          24097, 23836, 23571, 23304, 23033, 22760, 22485, 22207, 21926, 21644, 21360, 21075, 20788, 20500, 20211, 19922, 19631, 19341, 19050, 18759, 18469, 18179, 17889, 17601,
                          17313, 17027, 16742, 16458, 16176, 15896, 15618, 15342, 15068, 14796, 14527, 14261, 13997, 13736, 13478, 13223, 12971, 12722, 12476, 12233, 11994, 11758, 11526, 11297,
                          11072, 10850, 10631, 10416, 10205, 9997, 9793, 9592, 9395, 9201, 9011, 8824, 8641, 8461, 8285, 8112, 7942, 7776, 7613, 7453, 7297, 7144, 6994, 6847, 6703, 6562, 6424,
                          6289, 6157, 6028, 5901, 5777, 5656, 5538, 5422, 5309, 5198, 5089, 4983, 4880, 4778, 4679, 4583, 4488, 4395, 4305, 4216, 4130, 4046, 3963, 3882, 3803, 3726, 3651, 3577 };
 #elif defined(B3530)
  /*         B25/100: 3530         */
  uint16_t m_adc[151] = { 31484, 31421, 31355, 31286, 31215, 31140, 31062, 30980, 30896, 30807, 30715, 30620, 30521, 30417, 30310, 30199, 30084, 29965, 29842, 29714, 29582, 29446, 29305, 29160,
                          29010, 28856, 28697, 28534, 28366, 28193, 28016, 27834, 27648, 27457, 27261, 27061, 26857, 26648, 26435, 26217, 25996, 25770, 25540, 25307, 25069, 24828, 24583, 24335,
                          24084, 23829, 23571, 23311, 23048, 22782, 22514, 22244, 21971, 21697, 21422, 21144, 20866, 20586, 20306, 20024, 19743, 19461, 19178, 18896, 18614, 18332, 18051, 17770,
                          17491, 17212, 16935, 16659, 16384, 16111, 15840, 15571, 15304, 15039, 14776, 14516, 14258, 14003, 13750, 13500, 13253, 13009, 12767, 12529, 12294, 12062, 11833, 11607,
                          11385, 11166, 10950, 10737, 10528, 10322, 10120, 9920, 9725, 9532, 9343, 9157, 8974, 8795, 8619, 8446, 8276, 8110, 7947, 7786, 7629, 7475, 7324, 7176, 7031, 6889, 6750,
                          6613, 6479, 6349, 6220, 6095, 5972, 5851, 5733, 5618, 5505, 5394, 5286, 5180, 5077, 4975, 4876, 4779, 4684, 4591, 4500, 4411, 4324, 4239, 4156, 4074, 3994, 3916, 3840 };
 #elif defined(B3492)
  /*         B25/100: 3492         */
  uint16_t m_adc[151] = { 31456, 31392, 31326, 31256, 31184, 31108, 31029, 30947, 30862, 30773, 30680, 30584, 30484, 30381, 30273, 30162, 30046, 29927, 29803, 29675, 29543, 29406, 29266, 29121,
                          28971, 28817, 28659, 28496, 28328, 28156, 27980, 27799, 27613, 27423, 27229, 27030, 26827, 26620, 26408, 26192, 25972, 25749, 25521, 25289, 25054, 24815, 24573, 24327,
                          24078, 23826, 23571, 23314, 23054, 22791, 22526, 22259, 21989, 21719, 21446, 21172, 20897, 20621, 20343, 20066, 19787, 19508, 19229, 18951, 18672, 18393, 18115, 17838,
                          17562, 17286, 17012, 16739, 16468, 16198, 15929, 15663, 15399, 15136, 14876, 14618, 14363, 14110, 13859, 13611, 13366, 13124, 12885, 12648, 12415, 12184, 11957, 11733,
                          11512, 11294, 11079, 10867, 10659, 10454, 10252, 10054, 9858, 9666, 9478, 9292, 9110, 8931, 8755, 8582, 8413, 8246, 8083, 7922, 7765, 7611, 7460, 7311, 7166, 7023, 6883,
                          6746, 6612, 6481, 6352, 6225, 6102, 5981, 5862, 5746, 5632, 5521, 5412, 5305, 5200, 5098, 4998, 4900, 4804, 4710, 4618, 4528, 4440, 4354, 4269, 4187, 4106, 4027, 3950 };
 #else
  /*         B25/100: 3380         */
  uint16_t m_adc[151] = { 31370, 31304, 31235, 31163, 31088, 31011, 30930, 30845, 30758, 30667, 30573, 30475, 30373, 30268, 30159, 30047, 29930, 29810, 29685, 29557, 29425, 29288, 29148, 29003,
                          28854, 28701, 28543, 28382, 28216, 28046, 27872, 27693, 27511, 27324, 27133, 26938, 26739, 26536, 26329, 26118, 25903, 25685, 25463, 25238, 25009, 24777, 24542, 24304,
                          24062, 23818, 23571, 23322, 23070, 22816, 22560, 22302, 22042, 21781, 21518, 21254, 20988, 20722, 20454, 20186, 19918, 19649, 19380, 19111, 18842, 18573, 18305, 18038,
                          17771, 17505, 17240, 16976, 16713, 16452, 16192, 15934, 15678, 15423, 15171, 14920, 14672, 14426, 14182, 13941, 13702, 13466, 13232, 13001, 12773, 12548, 12325, 12105,
                          11888, 11674, 11463, 11255, 11050, 10847, 10648, 10452, 10259, 10069, 9882, 9698, 9517, 9339, 9164, 8992, 8822, 8656, 8493, 8333, 8175, 8020, 7868, 7719, 7573, 7429, 7288,
                          7150, 7015, 6881, 6751, 6623, 6497, 6374, 6254, 6135, 6020, 5906, 5795, 5685, 5578, 5474, 5371, 5270, 5172, 5075, 4980, 4888, 4797, 4708, 4621, 4535, 4451, 4370, 4289 };
 #endif
// WiFi
 String savedSSID="", savedPass="";
 bool hotspotMode = false;
 long RSSI = 0;
 String localIP = "";
WiFiClient espClient;
// Параметры MQTT
 // Cтруктура для хранения логов
struct MQTTDebugLog {
    String connectionLog;
    String lastError;
    String lastStatus;
    unsigned long lastAttemptTime;
    int connectionAttempts;
};
MQTTDebugLog mqttDebugLog;
// Глобальные переменные для времени работы
unsigned long startTime = 0;
unsigned long lastStatusUpdate = 0;
byte mqtt_attempts = MQTT_ATTEMPTS; // Количество попыток подключения при инициализации
bool mqtt_reconnection = MQTT_RECONNECTION; // Пытаться ли переподключаться при потере соединения
unsigned long mqtt_time_publication = MQTT_TIME_PUBLICATION; // Период публикаций 
String mqtt_server = MQTT_SERVER;
uint mqtt_port = MQTT_PORT;
String mqtt_user = MQTT_USER;
String mqtt_password = MQTT_PASSWORD;
String mqtt_topic_temp = MQTT_TOPIC_TEMP; // Топик для температур
String  mqtt_topic_press = MQTT_TOPIC_PRESS; // Топик для давлений
String mqtt_topic_alc = MQTT_TOPIC_ALC;   // Топик для спиртомера
String mqtt_topic_status = MQTT_TOPIC_STATUS;   // Топик для публикации статуса
PubSubClient mqttClient(espClient);

// Web Server Глобальные переменные
float setup_alc_k = 136.0;
float setup_alc_k_temp = 0.3;
uint8_t setup_alc_sensor = 1;
float setup_alc_target = 40.0;
bool debug_mode = false;
float Temp_debug[8] = {0.0, 25.0, 25.0, 25.0, 25.0, 25.0, 25.0, 25.0};
// NTC Setup variables
String m_adc_text = "";
bool ntc_setup_active = false;
float setup_R25 = 10.0;
float setup_R100 = 0.685;
float setup_T25 = 25.0;
float setup_T100 = 100.0;
float setup_U33 = 3.3;
float setup_Uref = 2.047;
float setup_R62 = 6.2;
float setup_R10 = 10.0;
float setup_B25 = 3950;
AsyncWebServer server(80);
const char* getSensorName(int8_t num);
String getSensorDataJSON();

// Объявления функций
void initOLED(); 
void EEPROM_Init();
void ADS_Init();
void ADS_Loop(); 
void initWiFi();
void setupWebServer();
void initOTA(); 
void setupMQTT();
void loopMQTT(); 

void setup() {                           // Инициализация             
   Serial.begin(115200);
  ESP.wdtEnable(10000);                  // Установка таймера watchdog  
  Wire.begin();                          // Инициализация I2C
  initOLED();                            // Инициализация OLED дисплея  

  EEPROM_Init();                        // Инициализация переменных из EEPROM
  pinMode(BtnEnter, INPUT_PULLUP);      // Инициализация кнопок
  pinMode(BtnSel, INPUT_PULLUP);  
  pinMode(BtnUp, INPUT_PULLUP);  
  pinMode(BtnDwn, INPUT_PULLUP);
  pinMode(Pin040DR1, INPUT_PULLUP); // Пин перемычки для определения наличия датчика давления 040DR1
  pinMode(pin_spk, OUTPUT);  digitalWrite(pin_spk, 0); // Готовим зуммер
  ADS_Init();

}
void loop() {         // Основной цикл
    ESP.wdtFeed();  // Сброс таймера watchdog
    ADS_Loop(); // Считываем температуры, выводим на дисплей, ожидаем запросов по 1ware
 
    static bool flstart = true;
    if (flstart) {
   unsigned long timeout = millis(); //ждем 12 сек, чтоб Самовар приконнектился, потом запускаем сетевые сервисы поочередно
  if (timeout >= 12000) {
    static bool wifistart = true, wificonnected = false;
      ESP.wdtFeed(); // Гладим собаку
      static long time_start_wifi;
      if (wifistart) {initWiFi(); wifistart = false; time_start_wifi = millis();  }              // Загрузка сохраненных данных и  запуск Wi-Fi
      else {
        if (WiFi.status() == WL_CONNECTED) wificonnected = true;
        else {if ((time_start_wifi + 10000) < millis()) {wificonnected = true; startHotspot();}}
      }
      ESP.wdtFeed();
      if (wificonnected) {
        setupWebServer();            // Запуск веб-сервера
        ESP.wdtFeed();
        initOTA();                   // Запуск ОТА
        ESP.wdtFeed();
        setupMQTT();                 // запуск MQTT
        flstart = false;}
    } 
    } else {                            // Когда сетевые сервисы запущены 
    MDNS.update(); ArduinoOTA.handle(); //Обработка ОТА
    loopMQTT();
    }
  
}
