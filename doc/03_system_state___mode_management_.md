# Глава 3: Управление состоянием и режимом системы

Добро пожаловать обратно! В [Главе 1: Взаимодействие с пользователем (веб и ЖК-дисплей)](01_user_interaction__web___lcd__.md) мы узнали, как давать команды Samovar. В [Главе 2: Выполнение программы процесса](02_process_program_execution_.md) мы увидели, как Samovar шаг за шагом следует «рецепту» (программе). Но как Samovar узнает, *какому* рецепту следует следовать? Он варит пиво, дистиллирует спиртные напитки или просто простаивает? И даже когда он выполняет рецепт, он в данный момент нагревается, выполняет определенный шаг или находится в режиме паузы?

Здесь на помощь приходит **управление состоянием и режимом системы**. Представьте себе эту часть программного обеспечения Samovar как его «мозг» или главного дирижера оркестра. Он отвечает за:

1.  Знание общего **режима** системы (например, ректификация, варка пива, простаивание). Это похоже на то, как дирижер выбирает, какое крупное музыкальное произведение исполнять.
2.  Знание текущего **состояния** системы в рамках этого режима или в целом (например, нагрев, выполнение этапа программы, пауза, ошибка). Это похоже на то, как дирижер руководит оркестром в части «Аллегро», делает «Паузу» или сигнализирует о «Перерыве».
3.  Управление **переходами** между этими режимами и состояниями на основе команд пользователя (глава 1), хода программы (глава 2) или непредвиденных событий (глава 6).

Без этого центрального управления самовар не знал бы, что делать с командами пользователя, как интерпретировать данные датчиков (глава 4) и управлять оборудованием (глава 5).

Возьмем типичный сценарий: вы только что закончили варить пиво (режим «Пиво») и теперь хотите очистить систему (возможно, с помощью программы ректификации/очистки) или начать дистилляцию спирта (режим «Ректификация»). Самовару нужен способ четко переключиться из режима «Система для пива» в режим «Система для дистилляции», а затем перейти из состояния «Простой» в состояние «Нагрев», а затем в состояние «Работа», следуя новой программе.

## Режимы: разные «шляпы» для Samovar

Samovar может работать несколькими различными способами, каждый из которых соответствует отдельному процессу или цели. Это его **режимы**. Код Samovar определяет их с помощью списка имен (`enum`):

```c++
// Из Samovar.h
enum SAMOVAR_MODE {SAMOVAR_RECTIFICATION_MODE, SAMOVAR_DISTILLATION_MODE, SAMOVAR_BEER_MODE, SAMOVAR_BK_MODE, SAMOVAR_NBK_MODE, SAMOVAR_SUVID_MODE, SAMOVAR_LUA_MODE};
volatile SAMOVAR_MODE Samovar_Mode; // Эта переменная хранит текущий режим.
```

*   `SAMOVAR_RECTIFICATION_MODE`: Для производства спиртных напитков высокой чистоты (ректификация).
* `SAMOVAR_DISTILLATION_MODE`: для более простой дистилляции спиртных напитков.
* `SAMOVAR_BEER_MODE`: для автоматизации этапов варки пива (затирание, кипячение).
* `SAMOVAR_BK_MODE`: для работы с определенным типом колонны (колонна Брага).
* `SAMOVAR_NBK_MODE`: для непрерывной дистилляции (колонна Начало Брага).
* `SAMOVAR_SUVID_MODE`: (вероятно, для Sous Vide, контроль температуры).
* `SAMOVAR_LUA_MODE`: для запуска пользовательских процессов, определенных в скриптах Lua.

Одновременно может быть активен только один режим. Переменная `Samovar_Mode` сообщает системе, какую «шапку» она сейчас носит. Ключевое слово `volatile` является немного техническим, но по сути оно сообщает компилятору, что эта переменная может быть изменена различными частями программы, которые работают независимо (например, главный цикл и, возможно, обработчики прерываний), поэтому система должна всегда считывать ее значение заново.

## Состояния: что происходит прямо сейчас?

В каждом режиме, или даже когда не запущен ни один конкретный процесс, Samovar находится в определенном **состоянии**. Эти состояния описывают его текущий уровень активности или состояние. Код использует целочисленную переменную `SamovarStatusInt` для отслеживания этого подробного состояния:

```c++
// Из Samovar.h
volatile int16_t SamovarStatusInt; // Хранит текущее рабочее состояние (в виде числа)
String SamovarStatus; // Хранит удобочитаемое описание состояния
```

В то время как `SamovarStatus` является текстовым описанием, которое вы можете прочитать на дисплее, `SamovarStatusInt` — это числовое значение, которое программа использует внутренне. Различные диапазоны чисел часто соответствуют разным режимам или фазам:

*   `0`: Простой / Выключено
*   `10`, `15`: Выполнение шага программы (режим выпрямления)
* `20`: Программа завершена
* `50`, `51`, `52`: Нагрев / Стабилизация (режим ректификации)
* `1000`: Режим дистилляции
* `2000`: Режим пива
* `3000`: Режим BK
* `4000`: Режим NBK
- И, возможно, другие для ошибок, калибровки, самотестирования и т. д.

Функция `get_Samovar_Status()` (см. `logic.h`) отвечает за просмотр `SamovarStatusInt` и других системных флагов (`PowerOn`, `PauseOn`, `program_Wait`, `ProgramNum` и т. д.) и генерацию описательного текста, отображаемого на ЖК-дисплее и в веб-интерфейсе.

```c++
// Упрощенный фрагмент из logic.h (фактическая функция довольно длинная)
String get_Samovar_Status() {
  if (!PowerOn) {
    SamovarStatusInt = 0; // Система выключена -> Состояние 0
    return F(«Выключено»);
  } else if (PowerOn && startval == 1 && !PauseOn && !program_Wait) {
    SamovarStatusInt = 10; // Включено, программа запущена, не приостановлена/не находится в режиме ожидания -> Состояние 10
    return «Прг №» + String(ProgramNum + 1); // Показать текущий шаг программы
  }
  // ... много других условий, проверяющих переменные состояния и ProgramNum ...
  else if (SamovarStatusInt == 2000) {
    // Если в режиме Beer (состояние 2000), опишите конкретный шаг программы Beer
    // ... проверьте program[ProgramNum].WType и время ...
    return «Прг №» + String(ProgramNum + 1) + «; » + «Beer specific status»;
  }
  // ... и так далее для других режимов (Distillation 1000, NBK 4000 и т. д.) ...
  return «Неизвестный статус»; // Запасной вариант по умолчанию
}
```

Эта функция запускается периодически для обновления информации, отображаемой на интерфейсах (глава 1). Однако основная логика полагается на числовые переменные `SamovarStatusInt` и `Samovar_Mode` для определения того, что *делает* система.

## Переходы между состояниями и режимами: смена передач

Наиболее важной задачей управления состоянием и режимом является обработка *переходов*. Так система переходит из состояния «Idle» в «Heating», из «Heating» в «Running Program Step 1», из «Running Step 1» в «Running Step 2» (в соответствии с логикой главы 2) или из «Rectification Mode» в «Beer Mode».

Эти переходы обычно запускаются:

1.  **Вводом пользователя:** нажатием кнопки на ЖК-дисплее или в веб-интерфейсе ([Глава 1: Взаимодействие с пользователем (веб и ЖК-дисплей)](01_user_interaction__web___lcd__.md)).
2.  **Завершением программы:** Завершение шага программы (например, достижение целевого объема, истечение таймера) ([Глава 2: Выполнение программы процесса](02_process_program_execution_.md)).
3.  **События, связанные с безопасностью:** Срабатывание сигнализации ([Глава 6: Мониторинг безопасности и сигнализация](06_safety_monitoring___alarms_.md)).

Как этот сигнал передается, например, от нажатия кнопки на веб-странице к изменению системных параметров `Samovar_Mode` или `SamovarStatusInt`?

Как показано в главе 1, веб-команды устанавливают специальную переменную: `sam_command_sync`. Эта переменная `volatile` действует как простое окно сообщений между веб-сервером/задачей LCD и основным циклом программы, который управляет состоянием и режимом.

```c++
// Из Samovar.h
enum SamovarCommands {SAMOVAR_NONE, SAMOVAR_START, SAMOVAR_POWER, SAMOVAR_RESET, CALIBRATE_START, CALIBRATE_STOP, SAMOVAR_PAUSE, SAMOVAR_CONTINUE, SAMOVAR_SETBODYTEMP, SAMOVAR_DISTILLATION, SAMOVAR_BEER, SAMOVAR_BEER_NEXT, SAMOVAR_BK, SAMOVAR_NBK, SAMOVAR_SELF_TEST, SAMOVAR_DIST_NEXT, SAMOVAR_NBK_NEXT};
volatile SamovarCommands sam_command_sync; // Переменная для передачи команд между задачами
```

Основная функция `loop()` в `Samovar.ino` постоянно проверяет `sam_command_sync`. Если она находит команду, отличную от `SAMOVAR_NONE`, она обрабатывает команду (часто изменяя `Samovar_Mode` или `SamovarStatusInt`) и затем сбрасывает `sam_command_sync` обратно в `SAMOVAR_NONE`.

Вот упрощенное представление этого процесса:

