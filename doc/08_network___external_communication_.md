# Глава 8: Сеть и внешние коммуникации

Добро пожаловать в последнюю главу руководства по Самовару! Мы уже рассмотрели много тем: как вы взаимодействуете с устройством ([Глава 1: Взаимодействие с пользователем (Web & LCD)](01_user_interaction__web___lcd__.md)), как оно выполняет технологические программы ([Глава 2: Выполнение технологических программ](02_process_program_execution_.md)), управляет своим состоянием ([Глава 3: Управление состоянием системы и режимами](03_system_state___mode_management_.md)), считывает данные с датчиков ([Глава 4: Сбор данных с датчиков](04_sensor_data_acquisition_.md)), управляет оборудованием ([Глава 5: Аппаратное управление (исполнители)](05_hardware_control__actuators__.md)), обеспечивает безопасность ([Глава 6: Мониторинг безопасности и тревоги](06_safety_monitoring___alarms__.md)) и сохраняет свои настройки ([Глава 7: Сохранение конфигурации](07_configuration_persistence__.md)).

Все эти возможности были бы ограничены, если бы Самовар мог работать только изолированно. Чтобы полностью раскрыть его потенциал, ему необходимо подключение к внешнему миру. Здесь вступает в игру **Сеть и внешние коммуникации**. Эта часть программного обеспечения Самовара отвечает за всё, что связано с выходом устройства в онлайн и его взаимодействием с другими устройствами и сервисами.

Представьте, что вы даёте Самовару сетевой кабель и смартфон. Это позволяет ему подключаться к вашей домашней сети (кабель), предоставляет мощный веб-интерфейс, доступный с любого компьютера или телефона (как встроенный сайт), и даже отправлять сообщения или данные в облачные сервисы или на ваш телефон (как смс или обновление удалённой панели).

## Почему сетевые коммуникации так важны: пример использования

Представьте, что вы запускаете долгий, многочасовой процесс варки. Физический LCD-экран хорош для быстрых проверок, когда вы рядом с Самоваром, но, скорее всего, вы не захотите стоять рядом всё это время. Возможно, вам потребуется:

1.  **Мониторить процесс удалённо:** Видеть текущую температуру, прогресс и статус с компьютера в другой комнате или даже со смартфона.
2.  **Изменять настройки или запускать действия удалённо:** Решить немного увеличить мощность нагревателя или поставить программу на паузу, не прикасаясь к устройству.
3.  **Получать оповещения:** Получить уведомление на телефон, если сработала тревога ([Глава 6: Мониторинг безопасности и тревоги](06_safety_monitoring___alarms__.md)) или когда завершился этап программы ([Глава 2: Выполнение технологических программ](02_process_program_execution_.md)).
4.  **Просматривать исторические данные:** Смотреть графики температур за всё время с компьютера.

Все эти сценарии требуют, чтобы Самовар был подключён к вашей сети и мог общаться внешне.

## Связи Самовара: ключевые понятия

Сетевые и внешние коммуникации Самовара включают несколько ключевых понятий:

1.  **Подключение к Wi-Fi:** Выход Самовара в вашу локальную беспроводную сеть.
2.  **Запуск веб-сервера:** Хостинг интерактивного веб-интерфейса, к которому вы обращаетесь через браузер.
3.  **Предоставление API-эндпоинтов:** Создание специфических web-адресов, с которыми работает веб-интерфейс для получения данных и отправки команд (как упоминалось в Главе 1).
4.  **Взаимодействие с внешними сервисами:** Отправка данных или сообщений на такие платформы, как Blynk, MQTT-брокеры или Telegram.

Рассмотрим эти моменты подробнее.

## Подключение: присоединение к Wi-Fi сети

Первый шаг — это подключение Самовара к вашей Wi-Fi сети. Для этого проект Самовар часто использует библиотеку `AsyncWiFiManager`, которая делает процесс очень удобным, особенно при первоначальной настройке.

Принцип работы таков:
*   При включении Самовар пытается подключиться к Wi-Fi сети, для которой он был ранее настроен (данные сохраняются благодаря [Главе 7: Сохранение конфигурации](07_configuration_persistence__.md)).
*   Если подключение успешно — он получает IP-адрес в вашей сети и готов к работе.
*   Если подключиться *не удалось* (например, первый запуск, изменилась сеть, неверный пароль), `WiFiManager` автоматически переводит Самовар в **режим точки доступа (AP Mode)**. То есть Самовар *сам* становится временной Wi-Fi точкой.
*   Далее вы подключаете свой компьютер или смартфон к *этой временной точке доступа Самовара*.
*   После подключения автоматически открывается портал настройки в браузере (или вы заходите по адресу `192.168.4.1`).
*   В этом портале вы выбираете вашу домашнюю Wi-Fi сеть из списка и вводите пароль.
*   После сохранения настроек `WiFiManager` сохраняет эти данные ([Глава 7: Сохранение конфигурации](07_configuration_persistence__.md)), отключает временную точку и пробует подключиться к выбранной домашней сети.
*   После успешного подключения Самовар полностью выходит в онлайн в вашей основной сети.

Это устраняет необходимость жёстко прописывать Wi-Fi-пароли в коде и делает ввод в эксплуатацию в разных условиях гораздо проще.

Посмотрите функцию `setup()` в `Samovar.ino` для логики подключения к Wi-Fi:

```c++
// Из Samovar.ino (упрощённая часть функции setup)
void setup() {
  // ... остальной код инициализации ...

  WiFi.mode(WIFI_STA); // Режим станции (подключение к существующей сети)
  WiFi.disconnect(true); // Начать с чистого состояния
  delay(50);
  WiFi.setHostname(host); // Дружелюбное имя устройства в сети

  // ... Инициализация SPIFFS/EEPROM (Глава 7) ...
  read_config(); // Загрузка сохранённой конфигурации (в т.ч. Wi-Fi)

  // ... Проверка, удерживается ли специальная кнопка при запуске для принудительного AP-режима ...
  bool wifiAP = false;
  // ... проверка состояния кнопки ...

  if (!wifiAP) {
    // Если не принудительно в AP-режиме, пробуем авто-подключение с сохранёнными данными
    AsyncWiFiManagerParameter custom_blynk_token("blynk", "blynk token", SamSetup.blynkauth, 33, "blynk token");
    AsyncWiFiManager wifiManager(&server, &dns); // Передаём объект веб-сервера

    // ... проверка нажатия кнопки для сброса настроек ...

    wifiManager.setConfigPortalTimeout(360); // Портал открыт 6 минут
    wifiManager.setSaveConfigCallback(saveConfigCallback); // Функция при сохранении настроек
    wifiManager.setAPCallback(configModeCallback); // Функция при входе в AP-режим
    wifiManager.setDebugOutput(false);
    // Можно добавить свои параметры в портал, например, для Blynk token
    wifiManager.addParameter(&custom_blynk_token); 

    if (!wifiManager.autoConnect("Samovar")) {
      // Если авто-подключение не удалось — остаёмся в AP-режиме, задаём инфо для отображения
      WiFi.mode(WIFI_AP);
      WiFi.softAP("Samovar", "SamApp123"); // SSID и пароль для AP
      StIP = WiFi.softAPIP().toString(); // IP адрес AP
    } else {
      // Если авто-подключение удалось, получаем локальный IP
      StIP = WiFi.localIP().toString(); 
    }

    if (shouldSaveWiFiConfig) { // Флаг из saveConfigCallback
      // Сохраняем, например, Blynk token после настройки Wi-Fi
      if (strlen(custom_blynk_token.getValue()) == 33) {
        strcpy(SamSetup.blynkauth, custom_blynk_token.getValue());
        save_profile(); // Сохраняем обновлённый SamSetup (Глава 7)
      }
    }
    Serial.print(F("Connected to "));
    Serial.println(WiFi.SSID()); // Имя подключённой сети
  } else {
    // Если принудительно в AP-режиме (по кнопке)
    WiFi.mode(WIFI_AP);
    WiFi.softAP("Samovar", "SamApp123");
    StIP = WiFi.softAPIP().toString();
    Serial.println(F("Started as WiFi AP"));
  }

  Serial.print(F("IP address: "));
  StIP.toCharArray(ipst, 16); // Сохраняем IP в глобальную переменную
  Serial.println(StIP);

  // ... Запуск mDNS (доступ по имени типа samovar.local) ...
  // ... Остальная инициализация ...
}
```
Этот фрагмент показывает, как `AsyncWiFiManager` обрабатывает как первичную попытку подключения, так и переход в AP-режим при необходимости. Функция `saveConfigCallback()` (здесь не показана, но простая) просто устанавливает флаг `shouldSaveWiFiConfig`, чтобы основная функция `setup` могла потом сохранить кастомные параметры, такие как токен Blynk, после настройки Wi-Fi.

Как только Самовар подключён к вашей сети, вы можете узнать его IP (обычно отображается на LCD или в serial-мониторе при загрузке) или использовать его hostname (например, `samovar.local`), если mDNS работает.

## Предоставление Dashboard: веб-сервер

Когда Самовар подключён к вашей сети, следующий шаг — запуск веб-сервера. Сервер слушает входящие запросы на определённом порту (обычно 80, стандартный для HTTP) и раздаёт веб-страницы (HTML, CSS, изображения), хранящиеся во внутренней файловой системе Самовара ([Глава 7: Сохранение конфигурации](07_configuration_persistence__.md)).

Всё это настраивается в функции `WebServerInit()` в `WebServer.ino`:

```c++
// Из WebServer.ino (упрощённая функция WebServerInit)
void WebServerInit(void) {
  FS_init(); // Инициализация файловой системы (SPIFFS/LittleFS) (Глава 7)

  // Настройка обработчиков для конкретных URL (эндпоинтов)
  server.on("/", HTTP_GET | HTTP_POST, [](AsyncWebServerRequest* request) {
    request->redirect("/index.htm"); // Перенаправление на index.htm
  });
  
  // Раздача статических файлов (HTML, CSS, картинки) прямо из файловой системы
  server.serveStatic("/style.css", SPIFFS, "/style.css").setCacheControl("max-age=5000");
  server.serveStatic("/alarm.mp3", SPIFFS, "/alarm.mp3");
  // ... другие статические обработчики ...

  // Раздача HTML-файлов с динамическим содержимым (через template processor)
  server.serveStatic("/index.htm", SPIFFS, "/index.htm").setTemplateProcessor(indexKeyProcessor).setCacheControl("max-age=800");
  server.serveStatic("/chart.htm", SPIFFS, "/chart.htm").setTemplateProcessor(indexKeyProcessor).setCacheControl("max-age=800");
  // ... другие динамические страницы ...

  // Обработчики API-эндпоинтов для JavaScript на странице
  server.on("/ajax", HTTP_GET, [](AsyncWebServerRequest *request) {
    getjson(); // Сбор данных в JSON-строку
    request->send(200, "text/html", jsonstr); // Отправка строки JSON
  });
  server.on("/command", HTTP_GET, [](AsyncWebServerRequest *request) {
    web_command(request); // Обработка команд с веб-страницы
  });
  server.on("/program", HTTP_POST, [](AsyncWebServerRequest *request) {
    web_program(request); // Обработка сохранения/загрузки программ
  });
  server.on("/save", HTTP_POST, [](AsyncWebServerRequest *request) {
    handleSave(request); // Обновление SamSetup из веб-формы
    save_profile(); // Сохранение SamSetup в файл/EEPROM (Глава 7)
    // ... ответ ...
  });
  // ... другие API-эндпоинты ...

  DefaultHeaders::Instance().addHeader("Access-Control-Allow-Origin", "*");  // Разрешить JavaScript с других доменов (для разработки)

  server.begin(); // Запуск веб-сервера!
#ifdef __SAMOVAR_DEBUG
  Serial.println("HTTP server started");
#endif
}
```

Этот код показывает, как настраивается библиотека `AsyncWebServer`. Она связывает определённые URL (`/`, `/style.css`, `/ajax`, `/command` и др.) либо с раздачей статических файлов из файловой системы, либо с выполнением функций на C++ (`getjson`, `web_command`, `handleSave`).

Функция `indexKeyProcessor` (и подобные, например, `setupKeyProcessor`) — часть механизма "template processor". Когда запрашивается страница типа `index.htm`, сервер читает HTML-файл и вызывает `indexKeyProcessor` для каждого найденного плейсхолдера (например, `%SteamColor%` или `%WProgram%`). Это позволяет подставлять динамические данные в HTML до отправки в браузер, чтобы веб-страница отражала актуальное состояние и настройки Самовара.

```c++
// Из WebServer.ino (упрощённый indexKeyProcessor)
String indexKeyProcessor(const String &var) {
  if (var == "SteamColor") return (String)SamSetup.SteamColor; // Цвет из SamSetup
  else if (var == "v") return SAMOVAR_VERSION; // Версия ПО
  // ... получение других значений из SamSetup или глобальных переменных (данные датчиков, статус и т.д.) ...
  else if (var == "WProgram") { // Для отображения структуры текущей программы
    if (Samovar_Mode == SAMOVAR_BEER_MODE) return get_beer_program();
    // ... строки программы для других режимов ...
    else return get_program(CAPACITY_NUM * 2);
  }
  // ... и другие плейсхолдеры HTML ...
  return ""; // Пустая строка, если плейсхолдер не распознан
}
```
Эта функция получает "живые" данные и настройки из переменных Самовара (`SamSetup`, структуры датчиков, глобальные флаги статуса) и форматирует их как строки для вставки в HTML веб-страницы.

## Внешние коммуникации: Blynk, MQTT, Telegram

Помимо веб-интерфейса, Самовар может отправлять данные *наружу* другим платформам и сервисам. Обычно это реализовано через отдельные задачи (например, `triggerGetClock`, которая отвечает за Telegram и Blynk, или MQTT-задачу).

### Blynk

Если включено (`#ifdef SAMOVAR_USE_BLYNK`), Самовар может подключаться к платформе Blynk. Blynk предоставляет мобильное приложение и конструктор веб-панелей, где вы можете создать собственный интерфейс для мониторинга и управления устройством удалённо.

Самовар отправляет данные *в* Blynk через `Blynk.virtualWrite()` и принимает команды *от* Blynk через макросы `BLYNK_WRITE`.

```c++
// Из Blynk.ino (упрощённо)
#ifdef SAMOVAR_USE_BLYNK

// Функция, регулярно отправляющая данные В Blynk (виртуальный пин V0)
BLYNK_READ(V0) {
  // Отправка температуры пара
  Blynk.virtualWrite(V0, SteamSensor.avgTemp); 
  // Отправка состояния питания
  Blynk.virtualWrite(V4, PowerOn); 
  // ... другие статусы ...
}

// Функция вызывается Blynk при взаимодействии с виджетом V3
BLYNK_WRITE(V3) {
  int State = param.asInt(); // Значение из виджета Blynk
  if (State == 1 && PowerOn) {
    // Если значение 1 и питание включено — команда SAMOVAR_START
    sam_command_sync = SAMOVAR_START; // (Сигнал главному циклу — Глава 3)
  } else {
    // Иначе — команда сброса
    sam_command_sync = SAMOVAR_RESET;
  }
}

// Для управления мощностью (виджет V16)
#ifdef SAMOVAR_USE_POWER
BLYNK_WRITE(V16) {
  float Value16 = param.asFloat(); // Целевое напряжение с виджета
  set_current_power(Value16); // Команда регулятору мощности (Глава 5)
}
#endif

#endif // SAMOVAR_USE_BLYNK
```
Здесь показан базовый шаблон: функции `BLYNK_READ` автоматически отправляют данные, а функции `BLYNK_WRITE` получают пользовательский ввод из приложения Blynk и превращают его в команды или действия Самовара.

### MQTT

Если включено (`#ifdef USE_MQTT`), Самовар может работать как MQTT-клиент, публикуя данные на MQTT-брокер. Это удобно для интеграции данных Самовара в системы домашней автоматизации (Home Assistant, Node-RED и др.) или другие IoT-панели.

Самовар отправляет данные в виде сообщений на определённые "топики".

```c++
// Из SamovarMqtt.h (упрощённо)
#ifdef USE_MQTT

// Функция отправки сообщения в MQTT-топик
void MqttSendMsg(const String &Str, const char *chart ) {
  // Формируем полный топик (например, "SMV/YOUR_BLYNK_TOKEN/log/3")
  strcpy(mqttstr1, mqttstr);
  strcat(mqttstr1, chart);
  strcat(mqttstr1, "/3"); // Версия сообщения

  // Копируем строку payload
  static char payload[PAYLOADSIZE];
  Str.toCharArray(payload, PAYLOADSIZE);

  // Публикуем сообщение
  uint16_t packetIdPub1 = mqttClient.publish(mqttstr1, 2, true, payload); // QoS 2, retain = true
  // ... обработка возможных проблем соединения и повтор ...
}

#endif // USE_MQTT
```
Функция `MqttSendMsg` вызывается из других частей кода (например, из `triggerSysTicker` в `Samovar.ino`) для отправки данных датчиков или статуса на MQTT-брокер. Формат данных — простая строка или CSV, которую затем парсит принимающая система.

### Telegram

Если включено (`#ifdef USE_TELEGRAM`), Самовар может отправлять текстовые уведомления в чат Telegram через Telegram-бота.

```c++
// Из Samovar.ino (упрощённая часть функции SendMsg)
void SendMsg(const String& m, MESSAGE_TYPE msg_type) {
  String MsgPl;
  
  // ... Логика MQTT (см. выше) ...

#ifdef USE_TELEGRAM
  if (SamSetup.tg_token[0] != 0 && SamSetup.tg_chat_id[0] != 0) { // Проверяем, настроен ли Telegram
    // Префикс по типу сообщения (тревога, предупреждение, уведомление)
    switch (msg_type) {
      case ALARM_MSG: MsgPl = F("*Тревога!*\n"); break;
      case WARNING_MSG: MsgPl = F("*Предупреждение!*\n"); break;
      case NOTIFY_MSG: MsgPl = ""; break;
      default: MsgPl = "";
    }
    MsgPl += " Самовар - " + m; // Добавляем само сообщение

    // Используем очередь и семафор для асинхронной отправки (без блокировки)
    if (xSemaphoreTake(xMsgSemaphore, (TickType_t)(50 / portTICK_RATE_MS)) == pdTRUE) {
      // Помещаем строку сообщения в очередь
      msg_q.push(MsgPl.c_str()); 
      xSemaphoreGive(xMsgSemaphore); // Освобождаем семафор
    }
  }
#endif

  // ... Логика отображения сообщения на LCD/веб (Глава 1) ...
}

// Из Samovar.ino (упрощённая часть задачи triggerGetClock)
void triggerGetClock(void *parameter) {
  // ... NTP, переподключение WiFi ...

#ifdef USE_TELEGRAM
  // Периодически проверяем, есть ли сообщения в очереди И есть ли интернет
  if (WiFi.status() == WL_CONNECTED && SamSetup.tg_token[0] != 0 && SamSetup.tg_chat_id[0] != 0 && Ping.ping("212.237.16.93", 1)) { // ping Telegram сервера
    if (!msg_q.isEmpty()) {
      if (xSemaphoreTake(xMsgSemaphore, (TickType_t)(50 / portTICK_RATE_MS)) == pdTRUE) {
        char c[200];
        msg_q.pop(&c); // Берём сообщение из очереди
        String qMsg = c;
        // Отправляем сообщение через HTTP GET к Telegram Bot API
        // urlEncode — для безопасности в URL
        http_sync_request_get(String("http://212.237.16.93/bot") + SamSetup.tg_token + "/sendMessage?chat_id=" + SamSetup.tg_chat_id + "&text=" + urlEncode(qMsg));
        xSemaphoreGive(xMsgSemaphore); // Освобождаем семафор
      }
    }
  } 
  // ... обработка оффлайн-случая ...
#endif

  // ... логика Blynk, MQTT, чтение давления/датчиков ...
}
```
Функция `SendMsg` подготавливает сообщение и кладёт его в очередь (`msg_q`), если Telegram настроен. Задача `triggerGetClock`, работающая в фоне, периодически проверяет эту очередь и, если есть сообщение и интернет, отправляет его через HTTP GET-запрос к серверу Telegram Bot API. Такой неблокирующий подход не задерживает основную логику Самовара. Для безопасности обращения к очереди используются семафоры.

## Заключение

В этой последней главе мы рассмотрели **Сеть и внешние коммуникации** — часть системы Самовара, которая позволяет ему подключаться к вашей Wi-Fi сети и взаимодействовать с внешним миром. Мы увидели, как `AsyncWiFiManager` упрощает подключение к Wi-Fi, в том числе при первоначальной настройке. Мы узнали, что Самовар запускает веб-сервер для интерактивной панели управления, раздаёт файлы из памяти ([Глава 7: Сохранение конфигурации](07_configuration_persistence__.md)), использует template processor для отображения динамических данных ([Глава 4: Сбор данных с датчиков](04_sensor_data_acquisition__.md)) и настроек. Мы также увидели, как веб-интерфейс использует API-эндпоинты для получения обновлений и отправки команд, которые затем обрабатываются основной логикой Самовара ([Глава 3: Управление состоянием системы и режимами](03_system_state___mode_management__.md)). Наконец, мы рассмотрели, как Самовар может общаться с внешними сервисами, такими как Blynk, MQTT и Telegram, предоставляя удалённый мониторинг, управление и уведомления, используя данные с датчиков и действия исполнительных механизмов ([Глава 5: Аппаратное управление (исполнители)](05_hardware_control__actuators__.md)).

Понимание сетевых коммуникаций — ключ к самым мощным функциям Самовара: удалённому мониторингу и управлению через веб- или мобильные приложения.

На этом завершается наше руководство по основным абстракциям проекта Самовар. Мы прошли путь от взаимодействия с пользователем и выполнения программ через управление состоянием системы, данные датчиков, аппаратное управление, безопасность, сохранение настроек и, наконец, подключение. Теперь у вас есть фундаментальное понимание того, как различные части программного обеспечения Самовара работают вместе для управления автоматизированными процессами варки и дистилляции.
