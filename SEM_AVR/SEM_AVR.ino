//Регулятор ТЭНа полуволнами с программным детектором нуля
//--https://alcodistillers.ru/forum/viewtopic.php?id=1549
//--JohnJohnov-----------------------
//--использован код OldBean----------
//--v0.2-------------------
//--добавлен дисплей
//--v0.3-------------------
//--ПИД-подстройка частоты сети по переходу через ноль
//--опрос кнопок
//--режим разгона
//--v0.4-------------------
//--выборки набираются за целое количество периодов
//--v0.5-------------------
//--оптимизация
//--v0.6-------------------
//--организована корректная обработка отсутствия сети
//--v0.7-------------------
//--исправлена ошибка выставления мощности менее 200Вт
//--битовые переменные упакованы в структуры
//--убрано ненужное мерцание символов на дисплее
//--добавлена возможность вернуть установленную мощность после экстренного отключения (идея d.styler)
//--v0.8-------------------
//--менюшка при возвращении уст.мощности после экстр.откл.
//--v0.81------------------
//--сделано выравнивание значений по правому краю
//--перекомпонован дежурный экран 
//--выводится установленная мощность в Вт и процентах
//--напряжение сети выводится с одним знаком после запятой
//--v0.9-------------------
//--оптимизация кода
//--переход на более другую библиотеку дисплея
//--русский шрифт
//--номинальная мощность устанавливается/записывается/выбирается в начальном меню
//--уставки, выбираемые в меню после экстр.откл., могут быть записаны в EEPROM
//--v0.95------------------
//--исправлены ошибки
//--значение задержки для защиты от дребезга вынесено в дефайны
//--
//--
//-------------------------
#include <Wire.h>
#include <EEPROM.h>
//#include <avr/eeprom.h>
//#include <OzOLED.h>
#include <ASOLED.h>
//
#define VERSION "v0.95"   // Версия скетча
#define VERSION_LEN 5     // Длина версии скетча в символах для правильного вывода на дисплей
//
//#define Debug           // Раскомментить для дебажения
#define High_level_triac  // Раскомментить, если твердотельное реле ТЭНа управляется ВЫСОКИМ уровнем, иначе НИЗКИМ
#define High_level_relay  // Раскомментить, если контактное реле ТЭНа управляется ВЫСОКИМ уровнем, иначе НИЗКИМ
//#define NOT_LM358       // Раскомментить, если в датчике напряжения стоит НЕ LM358, а rail-to-rail операционник
//#define DisplayReset    // Раскомментить, если используется вывод сброса дисплея
//
#define OLED_newADDRESS    (0x3C)   //Дисплей OLED 128х64
//
#define pin_OLED_res 2    //  Пин сброса OLED индикатора.
#define pin_VACin 0       //  Пин входа измеряемого напряжения (A0)
#define pin_TOut 4        //  Пин выхода управления ТЭНом (на твердотельное реле)
#define pin_TRelay 6      //  Пин выхода управления ТЭНом (на контактное реле в режиме максимальной мощности)
#define pin_ZeroOut 5     //  Пин выхода импульса ноля
#define pin_DebugOut 7    //  Пин для отладки
#define pin_TestOut 3     //  Пин для отладки

//
#define pin_butt_1 10     // Пин кнопки "Р-". Уменьшение уставки мощности.
#define pin_butt_2 9      // Пин кнопки "Р+". Увеличение уставки мощности.
#define pin_butt_3 12     // Пин кнопки "Стоп". Экстренное отключение ТЭНа.
#define pin_butt_4 11     // Пин кнопки "Разгон". Включение/отключение разгона.
#define pin_buttGND 8     // Пин временного общего провода для подключения кнопок.
#define DEBOUNCE 21       // Значение для обеспечения защиты от дребезга кнопок DEBOUNCE=1 + <задержка в ms>/10
//
#define U_ZERO 512              // Значение нуля АЦП для двуполярного сигнала с постоянной составляющей на выходе ОУ
#define LINE_FREQ 155           // Определяет начальную частоту для фазовой автоподстройки частоты сети (50,08Гц)
#define T_ADC 49                // Определяет интервал между запусками АЦП (200 мкс)
//f_OCn = f_clk / 2*N*(1 + X), где N - коэффициент деления предделителя, X- содержимое регистра OCRnA
#define PSUM_MAX 50             // Количество периодов для набора отсчетов АЦП (50 - это за 1 сек, это порядка 5000 отсчетов)
#define ZSUM_MAX 5000           // Количество отсчетов АЦП без детекции ноля (5000 отсчетов это порядка 1 сек)
#define CICLE 200               // Количество полупериодов в полном цикле регулирования (200 полупериодов - 2сек, если устанавливать более 255 - надо менять размерность сопутствующих переменных )
//
#define Kp 1        // Коэффициент пропорциональности для ПИД-подстройки ФЧ сети (степень двойки для регистрового сдвига)
#define Ki 5        // Интегральный коэффициент для ПИД-подстройки ФЧ сети (степень двойки для регистрового сдвига)
#define Kd 2        // Дифференциальный коэффициент для ПИД-подстройки ФЧ сети (степень двойки для регистрового сдвига)
#define Km 6        // Коэффициент для целочисленной математики (степень двойки для регистрового сдвига)
#define Phase 8     // сдвиг фаз между детекцией ноля и прерыванием таймера (в тиках таймера)
//
#define U_LINE_Q 52900      // Квадрат номинала сети, для которого указана номинальная мощность ТЭНа (230В)
static uint16_t Pnom;       // Номинальная мощность ТЭНа (хранится в EEPROM и устанавливается из менюшки)
#define Pnom_ARRAY_SIZE 8   // Макс. размер массива записанных номинальных мощностей ТЭНа sizeof(Pnom_arr)/sizeof(Pnom_arr[0])
static uint16_t Pnom_arr[Pnom_ARRAY_SIZE];  // Массив мощностей ТЭНа
static uint8_t Pnom_number; // Номер активной предустановки мощности
#define PDMset_SIZE 6       // Размер массива уставок мощности ТЭНа sizeof(PDMset)/sizeof(PDMset[0]) (ставить не меньше 4)
static uint16_t PDMset[2][PDMset_SIZE] = {CICLE/5,2*CICLE/5,CICLE/2,3*CICLE/5,4*CICLE/5,CICLE}; // Массив уставок мощности ТЭНа
//
// В EEPROM хранятся значения номинальных мощностей ТЭНа (8 значений в первых 16 байтах, определяется величиной Pnom_ARRAY_SIZE)
// и уставки мощности для каждой номинальной в формате pdm (занимает 1 байт),
// уставки пишутся не в конкретные ячейки, а по кругу до заполнения выделенного участка EEPROM.
// Так сделано для экономии ресурса EEPROM
#define EEPROM_SIZE 1024                // Значение емкости EEPROM в байтах (1024 для Arduino NANO)
static volatile uint16_t old_addr = 0;  // Адрес в EEPROM, где записана самая старая уставка
static volatile uint16_t new_addr = 0;  // Адрес в EEPROM, куда писать новую уставку
static volatile uint16_t start_addr = 0;// Начальный адрес области записи уставок в EEPROM
static volatile uint16_t end_addr = 0;  // Конечный адрес области записи уставок в EEPROM
static volatile uint16_t clear_old_addr;// Дубль адреса в EEPROM, где записана самая старая уставка, предназначенная для стирания
//
static volatile uint32_t sum;               // Сумматор квадратов отсчетов АЦП
static volatile uint32_t U_sum = 0;         // Сумма квадратов отсчетов АЦП, готовая для обработки
static volatile uint16_t sc = 0;            // Счетчик просуммированных квадратов
static volatile uint16_t sc_sum = 0;        // Счетчик просуммированных квадратов, готовый к обработке
static volatile uint16_t sc_notzero = 0;    // Счетчик выборок АЦП без перехода через ноль
static volatile uint8_t  pdm = 0;           // Текущий уровень PDM (принимает значения от 0 до CICLE)
static volatile uint32_t Pust = 0;          // Установленная мощность ТЭНа
static volatile uint8_t PDMust = 0;         // PDM, соответствующий установленной мощности ТЭНа
static volatile uint8_t PDMcount = 0;       // Счетчик для перебора уставок мощности ТЭНа
//
static uint16_t U_real = sqrt(U_LINE_Q);    // Среднеквадратичное за секунду (целая часть)
static uint8_t U_real_dec = 0;              // Среднеквадратичное за секунду (дробная часть)
//
static volatile int16_t Uold = 0;           // Буферная переменная для НЧ-фильтрации
static volatile int32_t Udelta = 0;         // Буферная переменная для НЧ-фильтрации
static volatile int16_t lev = 0, err = 0;   // Буферные переменные для реализации PDM методом диффузии (смещения) ошибки
static volatile int8_t ps = 0;              // Буферная переменная для реализации PDM методом диффузии (смещения) ошибки
//
static volatile uint8_t PID_ust = LINE_FREQ;        // Данные для установки регистра сравнения таймера2
static volatile uint16_t PID_reg = PID_ust << Km;   // Функция управления ПИД
static volatile int32_t PID_err_old = 0;            // Разность фаз из предыдущего шага
static volatile int32_t PID_int = 0;                // Интегральная составляющая из предыдущего шага
//
static volatile struct flags {
  unsigned  zero : 1;         // Флаг перехода через ноль
  unsigned  PP : 1;           // Флаг начала очередного полупериода
  unsigned  PVolna : 1;       // Флаг полуволны ((отрицательная = 0, положительная = 1)
  unsigned  sum : 1;          // Флаг готовности насуммированных данных к обработке
  unsigned  Tout : 1;         // Флаг включения ТЭНа (твердотельное реле)
  unsigned  TRelay : 1;       // Флаг включения ТЭНа (контактное реле)
  unsigned  Ulow : 1;         // Флаг невозможности выдать установленный уровень мощности
  unsigned  Udown : 1;        // Флаг аварии сети (действующее напряжение ниже 100В)
  unsigned  NotZero : 1;      // Флаг аварии сети (не детектируются переходы через ноль)
  unsigned  razg : 1;         // Флаг режима "разгон"
  unsigned  razg_on : 1;      // Флаг начала режима "разгон"
  unsigned  butt : 1;         // Флаг опроса кнопок
  unsigned  writable : 1;     // Флаг записи уставок в EEPROM
  unsigned  DisplayOut : 1;   // Флаг вывода на дисплей обновленных данных
  unsigned  dspRefresh : 1;   // Флаг выхода из режима меню / обновления экрана
  unsigned  dspMenu : 2;      // Индикатор режима меню
} fl = {0};
//
//
byte X_position (const byte x, const uint16_t arg = 1); // Функция возвращает начальную позицию по Х для десятичного числа, в зависимости от количества знаков в нём.
byte X_centred (const byte len);    // Функция возвращает начальную позицию по Х для текста длинной len знаков, для размещения оного по центру дисплея.
//ASOLED ASOled;
#define ASOled LD // Заюзаем уже созданный в библиотеке дисплея объект LD
//
//==============================================================================
//============================ПРОЦЕДУРЫ И ФУНКЦИИ===============================
//==============================================================================
//
// Функция возвращает начальную позицию по Х для десятичного числа, в зависимости от количества знаков в нём.
byte X_position (const byte x, const uint16_t arg) { // arg-выводимое число; х-позиция для arg, если бы оно было однозначно
  byte pix = 6; // Ширина шрифта в пикселях
  if (arg > 999) return pix * (x-3);
  else if (arg > 99) return pix * (x-2);
  else if (arg > 9) return pix * (x-1);
  else return pix * x;
}
//
// Функция возвращает начальную позицию по Х для текста длинной len знаков, для размещения оного по центру дисплея.
byte X_centred (const byte len) { // len - Количество знакомест в тексте
  byte wdt = 128; // Ширина дисплея в пикселях
  byte pix = 6;   // Ширина шрифта в пикселях
  if (len > wdt/pix) return 0;
  else return (wdt - (len * pix))/2;
}
//
void EEPROM_read_Pnoms() { //===========Подпрограмма чтения начальных данных из EEPROM================
//
  for (int x = 0; x < Pnom_ARRAY_SIZE; x++) {
    Pnom_arr[x] = eeprom_read_word((uint16_t*)(x * 2));
    Pnom_number = x;
    Pnom = Pnom_arr[Pnom_number];
    if (Pnom == 0xffff) { // Дошли до пустой ячейки
      if (x) Pnom = Pnom_arr[x-1];
      break;
    }
  }
}//===========Подпрограмма чтения начальных данных из EEPROM================
//
void EEPROM_read_PDMs() { //===========Подпрограмма чтения уставок из EEPROM для выбранной Pnom================
//
  uint16_t PDMtmp[2][PDMset_SIZE] = {0};
  int8_t tmpcount = 0; int16_t x;
  x = (EEPROM_SIZE - 2 * Pnom_ARRAY_SIZE)/(Pnom_ARRAY_SIZE);// Размер области для записи уставок в EEPROM
  start_addr = Pnom_ARRAY_SIZE * 2 + Pnom_number * x;       // Начальный адрес области
  end_addr = start_addr + x - 1;                            // Конечный адрес области
  //
  uint8_t y = eeprom_read_byte((uint8_t*)end_addr); // Прочтем последнюю ячейку области
  if (y != 0xff) {                                  // Если считанное значение не пустое, то
    for (x = end_addr + 2 - PDMset_SIZE; x <= end_addr; x++) {  // Почитаем из области для записи уставок в EEPROM, начиная с конца
      uint8_t y = eeprom_read_byte((uint8_t*)x);
      if (y != 0xff) {            // Если считанное значение не пустое, то
        PDMtmp[0][tmpcount] = y;  // запишем его в массив уставок
        PDMtmp[1][tmpcount] = x;  // и туда же запишем адрес значения в памяти EEPROM
        if (++tmpcount > PDMset_SIZE-2) break;  // Закончим, заполнив массив
      }
    }
    if (tmpcount < PDMset_SIZE - 1) { // Проверим массив уставок на заполненность и если не полон, то
      for (x = start_addr; x < start_addr + PDMset_SIZE - 3; x++) {  // Почитаем ещё из области для записи уставок в EEPROM, начиная с начала
        uint8_t y = eeprom_read_byte((uint8_t*)x);
        if (y != 0xff) {            // Если считанное значение не пустое, то
          PDMtmp[0][tmpcount] = y;  // запишем его в массив уставок
          PDMtmp[1][tmpcount] = x;  // и туда же запишем адрес значения в памяти EEPROM
          if (++tmpcount > PDMset_SIZE-2) break;  // Закончим, заполнив массив
        }
      }
    }
  }
  else {  // Если последняя ячейка области не заполнена
    for (x = start_addr; x <= end_addr; x++) {  // Почитаем из области для записи уставок в EEPROM
      uint8_t y = eeprom_read_byte((uint8_t*)x);
      if (y != 0xff) {            // Если считанное значение не пустое, то
        PDMtmp[0][tmpcount] = y;  // запишем его в массив уставок
        PDMtmp[1][tmpcount] = x;  // и туда же запишем адрес значения в памяти EEPROM
        if (++tmpcount > PDMset_SIZE-2) break;  // Закончим, заполнив массив
      }
    }
  }
  if (tmpcount--) { // Декрементируем счетчик и если записанные уставки есть, то...
    new_addr = PDMtmp[1][tmpcount];                   // Адрес для записи новой уставки...
    if (++new_addr > end_addr) new_addr = start_addr; // на единицу больше адреса последней считанной, но не больше границы области
    if (tmpcount == PDMset_SIZE-2) {  // Если массив полон
      old_addr = PDMtmp[1][0]; // то адрес самой старой уставки в нулевой ячейке
    }
    {  // Уберем дублирующиеся значения
      uint8_t PDMdiff[PDMset_SIZE] = {0}; // Заведем временный массив совпадений
      for (x = 0; x < PDMset_SIZE; x++) { // Пробежимся по обоим массивам
        for (int y = 0; y <= tmpcount; y++) {
          if (PDMset[0][x] == PDMtmp[0][y]) ++PDMdiff[x]; // И заполним массив совпадений
        }
      }
      for (x = 0; x < PDMset_SIZE - 1; x++) { // Сортируем
        for (int y = x + 1; y < PDMset_SIZE; y++) {
          if (PDMdiff[y]) {             // Если в данной позиции есть совпадение
            uint8_t z = PDMset[0][x];
            PDMset[0][x] = PDMset[0][y];// Обмениваемся
            PDMset[0][y] = z;
            PDMdiff[y] = PDMdiff[x];
            break;
          }
        }
      }
    }
    for (x = 0; x <= tmpcount; x++) { // Допишем в рабочий массив считанное из EEPROM
      PDMset[0][x] = PDMtmp[0][x];
      PDMset[1][x] = PDMtmp[1][x];
    }
  }
  else {          // Записанных уставок нет
    new_addr = start_addr;  // Адрес для записи новой уставки равен начальному
  }
}//===========Подпрограмма чтения уставок из EEPROM для выбранной Pnom================
//
void ADC_init() { //===============Инициализация АЦП===================
  ADMUX = 0;
  ADMUX |= ( 1 << REFS0);  // Задаем ИОН равный напряжению питания
  ADMUX |= (0 & 0x07);    // Выбираем пин A0 для преобразования
  ADCSRA |= (1 << ADPS2 ) | (1 << ADPS1) | (1 << ADPS0); // предделитель на 128
  ADCSRA |= (1 << ADIE);  // Разрешаем прерывания по завершении преобразования
  ADCSRA |= (1 << ADEN);  // Включаем АЦП
}//================================Инициализация АЦП===================
//
void Timers_init() { //===============Инициализация таймеров===================
  //---Инициализация таймера 0 для тактирования АЦП -------------
  TCCR0A = 0;
  TCCR0B = 0;
  TCCR0A |= (1 << WGM01); // Счетчик работает в режиме CTC (сброс по совпадению)
  TCCR0B |= (1 << CS01) | (1 << CS00); // Предделитель на 64 (на счетчик - 250 кГц)
  OCR0A = T_ADC; // Определяет период запуска АЦП
  TIMSK0 |= (1 << OCIE0A); // Разрешаем прерывания по совпадению с OCR0A
  // Инициализация таймера 2 для формирования импульса нуля Zero
  TCCR2A = 0;
  TCCR2B = 0;
  TCCR2A |= (1 << WGM21); // Счетчик работает в режиме CTC (сброс по совпадению)
  TCCR2B |= (1 << CS22) | (1 << CS21) | (1 << CS20); // Предделитель на 1024 (сч. - 15.625 кГц/64мкс)
  OCR2A = LINE_FREQ; // Прерывание с удвоенной частотой сети
  TIMSK2 |= (1 << OCIE2A); // Разрешаем прерывания по совпадению с OCR2A
}//=================================Инициализация таймеров===================
//
void Pins_init() { //======Инициализация входов/выходов контроллера=========
#ifdef DisplayReset
  pinMode(pin_OLED_res, OUTPUT);      // Определяем вывод сброса дисплея, как выход
  digitalWrite(pin_OLED_res, LOW);    // Сбрасываем дисплей (!!! НЕ ЗАБЫТЬ ПЕРЕКЛЮЧИТЬ НА ВЫСОКИЙ !!!)
#endif
  pinMode(pin_TOut, OUTPUT);          // Определяем вывод твердотельного реле, как выход
  pinMode(pin_TRelay, OUTPUT);        // Определяем вывод контактного реле, как выход
#ifdef High_level_triac // управление высоким уровнем
  digitalWrite(pin_TOut, LOW);        // Выключаем ТЭН (твердотельное реле)
#else // управление низким уровнем
  digitalWrite(pin_TOut, HIGH);       // Выключаем ТЭН (твердотельное реле)
#endif
#ifdef High_level_relay // управление высоким уровнем
  digitalWrite(pin_TRelay, LOW);        // Выключаем ТЭН (контактное реле)
#else // управление низким уровнем
  digitalWrite(pin_TRelay, HIGH);       // Выключаем ТЭН (контактное реле)
#endif
  //
  pinMode(pin_buttGND, OUTPUT);      // Определяем временный общий кнопок, как выход
  digitalWrite(pin_buttGND, LOW);    // и устанавливаем на нем низкий уровень
  pinMode(pin_butt_1, INPUT_PULLUP); // Определяем вывод кнопки 1, как вход и подтягиваем его внутренним резюком к VCC
  pinMode(pin_butt_2, INPUT_PULLUP); // Определяем вывод кнопки 2, как вход и подтягиваем его внутренним резюком к VCC
  pinMode(pin_butt_3, INPUT_PULLUP); // Определяем вывод кнопки 3, как вход и подтягиваем его внутренним резюком к VCC
  pinMode(pin_butt_4, INPUT_PULLUP); // Определяем вывод кнопки 4, как вход и подтягиваем его внутренним резюком к VCC
  //
#ifdef Debug
  pinMode(pin_ZeroOut, OUTPUT);       // Определяем вывод импульса ноля, как выход
  digitalWrite(pin_ZeroOut, LOW);     //
  pinMode(pin_DebugOut, OUTPUT);      // Определяем отладочный вывод, как выход
  digitalWrite(pin_DebugOut, LOW);    //
  pinMode(pin_TestOut, OUTPUT);       // Определяем отладочный вывод, как выход
  digitalWrite(pin_TestOut, LOW);     //
#endif
}//========================Инициализация входов/выходов контроллера=========
//
void Razgon_() { //===========Подпрограмма обработки режима разгона================
  static uint8_t   PPcount_R = 0;   // счетчик полупериодов
    if (fl.razg_on &&               // Если включен разгон..
        !fl.TRelay &&               // ..и НЕ включено контактное реле
        (++PPcount_R == 50)) {      // ..и все это длится уже более 500мс,
      fl.TRelay = 1; PPcount_R = 0; // то включим контактное реле и обнулим счетчик
    }
    if (fl.razg &&                  // Если включен максимум для твердотельного реле..
        !fl.razg_on &&              // ..и выключен разгон
        (++PPcount_R == 50)) {      // ..и все это длится уже более 500мс,
      fl.razg = 0; PPcount_R = 0;   // то выключим реле и обнулим счетчик
    }
}//===========Подпрограмма обработки режима разгона================
//
void PDM_() { //===========Подпрограмма управления твердотельным реле ТЭНа================
  if (fl.razg) {
    pdm = CICLE; // В режиме разгона твердотельное всегда открыто
  }
  lev = pdm + err;                // Текущий уровень с учетом ошибки дискретизации, сделанной на предыдущем полупериоде.
  //Текущее значение постоянной составляющей
  if (fl.PVolna) ps -= fl.Tout; // Декрементируем ps, если в прошлую отрицательную полуволну твердотельное реле было включено
  else ps += fl.Tout;           // Инкрементируем ps, если в прошлую положительную полуволну твердотельное реле было включено
//
  if ((lev >= CICLE/2) && ((ps == 0) || (fl.PVolna && (ps < 0)) || (!fl.PVolna && (ps > 0)))) { // Ставим флаг включения ТЭНа с учетом значения постоянной составляющей
    fl.Tout = 1; err = lev - CICLE;         // и считаем ошибку для следующего полупериода
  }        
  else {
    fl.Tout = 0; err = lev;                 // Снимаем флаг включения ТЭНа и считаем ошибку
  }
}//========================Подпрограмма управления твердотельным реле ТЭНа================
//
void Buttons_() { //==============Опрос кнопок=====================
  static struct buttons {
    unsigned butt : 4;      // код текущей нажатой кнопки
    unsigned last_butt : 4; // код предыдущей нажатой кнопки
    unsigned butt_1 : 1;    // текущее состояние кнопки (0 - не нажата)
    unsigned butt_2 : 1;    // текущее состояние кнопки
    unsigned butt_3 : 1;    // текущее состояние кнопки
    unsigned butt_4 : 1;    // текущее состояние кнопки
    unsigned no_select : 1; // вспомогательный флажок для начального меню
    unsigned writePnom : 1; // вспомогательный флажок записи нового Pnom в EEPROM
    unsigned clear_old : 1; // вспомогательный флажок стирания старой уставки из EEPROM
  } bt ={0};
  static uint8_t butt_count = 0;        // счетчик для устранения дребезга
  static uint8_t butt_force_count = 0;  // счетчик для форсирования инкремента/декремента
  //
  if (bt.clear_old) { //=====Стираем старую уставку, если нужно
    eeprom_update_byte((uint8_t*)clear_old_addr,0xff); // Стираем самую старую уставку
    bt.clear_old = 0;                               // Снимаем флажок стирания
  }
  bt.butt_1 = !digitalRead(pin_butt_1);
  bt.butt_2 = !digitalRead(pin_butt_2);
  bt.butt_3 = !digitalRead(pin_butt_3);
  bt.butt_4 = !digitalRead(pin_butt_4);
  byte button_sum = bt.butt_1 + bt.butt_2 + bt.butt_3 + bt.butt_4;
  if ( (button_sum == 0) && butt_force_count ) butt_force_count--; // уменьшаем счетчик форсирования инкремента/декремента
  if ( button_sum == fl.butt ) { // Или нажата одна кнопка или ни одной
    bt.butt = bt.butt_1 + (bt.butt_2 << 1) + (bt.butt_3 << 2) + (bt.butt_4 << 3);
    if ( bt.butt == bt.last_butt ) {
      butt_count++;
    }
    else {
      butt_count = 1;
      bt.last_butt = bt.butt;
    }
  }
  else if (--butt_count < 1) {
    butt_count = 1;
  }
  //
  if ( butt_count == DEBOUNCE ) { // Есть нажатая кнопка или достаточная пауза после нажатия
    switch (fl.dspMenu) { //=====Проверяем режимы меню
      case 2:  {  //=============Если мы в начальном меню, то...
        switch (bt.butt) {
          case 1: { //-----Кнопкой "P-" перебираем записанные значения или уменьшаем значение Pnom
            if (bt.no_select) { //Если не выбираем, а вводим значение,...
              if (butt_force_count > 20) {      // Если очень долго держим...
                if (Pnom > 100) Pnom -= 100;    // Убавляем по соточке, пока есть куда
                else butt_force_count = 10;     // Если некуда убавлять - снижаем форсаж
              }
              else if (butt_force_count > 10) { // Если долго держим...
                if (Pnom > 10) Pnom -= 10;      // Убавляем по десяточке, пока есть куда
                else butt_force_count = 0;      // Если некуда убавлять - снижаем форсаж
              }
              else {
                if (--Pnom == 0) Pnom=1;        // Убавляем по чуть-чуть
              }
            }
            else {  //Если выбираем из записанных в EEPROM...
              if (++PDMcount > Pnom_number) PDMcount=0; // Перебираем значения уставок мощности ТЭНа
              Pnom = Pnom_arr[PDMcount];
            }
            butt_force_count++;
            break;                      //Закончили
          }
          case 2: { //-----Кнопкой "P+" увеличиваем значение Pnom
            if (butt_force_count > 20) {
              if ((Pnom += 100) > 9999) Pnom=9999;// Если очень долго держим, прибавляем по соточке
            }
            else if (butt_force_count > 10) {
              if ((Pnom += 10) > 9999) Pnom=9999; // Если долго держим, прибавляем по десяточке
            }
            else {
              if (++Pnom > 9999) Pnom=9999;       // Прибавляем по чуть-чуть
            }
            bt.no_select = 1;
            butt_force_count++;
            break;                      //Закончили
          } 
          case 4: { //-----Кнопкой "Стоп" пишем значение в память и выходим из менюшки
            bt.writePnom = 1; // Ставим флаг записи нового значения Pnom в EEPROM
          }
          case 8: { //-----Кнопкой "Разгон" выходим из менюшки
            if (Pnom < 10000) { // Если значение реальное...
              if (bt.no_select) { // Если значение НЕ выбрано из записанных в EEPROM, а введено...
                int x; int y = 0;
                  for (x = Pnom_number; x >= 0; x--) {  // Проверим новое значение на совпадению с уже записанными
                    if (Pnom == Pnom_arr[x]) {
                      y = 1;
                      break;
                    }
                  }
                  if (y) {  // Если такое значение уже есть в EEPROM...
                    Pnom_number = x;  // Запомним порядковый номер совпавшего Pnom
                    bt.writePnom = 0; // Снимем флаг записи нового значения Pnom в EEPROM
                    fl.writable = 1;  // Ставим флаг записи уставок в EEPROM
                  }
                  else {  // Если такого значения в EEPROM нету...
                    Pnom_number = PDMcount;     // Запомним порядковый номер вновь введенного Pnom и...
                    fl.writable = bt.writePnom; // ставим флаг записи уставок в EEPROM, если туда просили записать Pnom
                  }
               }
               else { // Если значение выбрано из записанных в EEPROM...
                Pnom_number = PDMcount; // Запомним порядковый номер выбранного Pnom
                bt.writePnom = 0;       // Снимем флаг записи нового значения Pnom в EEPROM
                fl.writable = 1;        // Ставим флаг записи уставок в EEPROM
               }
              //
              PDMcount=0;       //Сбрасываем счетчик
              //
              if (fl.writable) {  // Если уставки пишутся в EERPOM, то
                EEPROM_read_PDMs(); // читаем ранее записанное
              }
              if (bt.writePnom) { // Запишем новое значение Pnom, если необходимо
                eeprom_update_word((uint16_t*)(Pnom_number * 2),Pnom);
                bt.writePnom = 0; // и сбросим флаг записи нового значения Pnom
              }
              fl.dspMenu = 0;   //Снимаем флаг перехода в меню
              fl.dspRefresh = 1;//Ставим флаг обновления экрана
            }
            fl.butt = 0;        //После нажатия должна быть пауза
            break;              //Закончили
          }
          default:
            fl.butt = 1;        // достаточная пауза между нажатиями
        }
        break;
      }
      case 1:  {  //=============Если мы в меню выбора уставки, то...
        switch (bt.butt) {
          case 1: { //=====По кнопке "Р-" перебираем значения
            if (++PDMcount > PDMset_SIZE - 1) PDMcount=0; //Перебираем значения уставок мощности ТЭНа
  //          fl.butt = 0;            //После нажатия должна быть пауза          
            break;                    //Закончили
          }
          case 2: { //=====По кнопке "Р+" перебираем значения
            if (PDMcount-- == 0) PDMcount=PDMset_SIZE - 1;//Перебираем значения уставок мощности ТЭНа
  //          fl.butt = 0;            //После нажатия должна быть пауза          
            break;                    //Закончили
          }
          case 4: { //=====По кнопке "стоп" записываем уставку, если нужно, принимаем и выходим
            PDMust = PDMset[0][PDMcount];//Устанавливаем выбранную мощность ТЭНа
            if (fl.writable) {  // Если уставки запоминаются...
              if (!PDMset[1][PDMcount]) { // Если просят записать НЕ уже записанное...
                eeprom_update_byte((uint8_t*)new_addr,PDMset[0][PDMcount]); // Пишем новую уставку
                PDMset[1][PDMcount] = new_addr; // Заносим в массив адрес свежезаписанной уставки
                if (++new_addr > end_addr) new_addr = start_addr; // Инкрементируем адрес для новой уставки и следим, чтобы не выходило за границы области
                if (PDMcount == PDMset_SIZE - 1) {  // Если новое значение - последнее в списке
                  //
                  if (!old_addr) {  // Если в массиве уставок есть незаписанные в EEPROM значения, то сначала стираем их
                    boolean swapped = 1; int upper_index = PDMset_SIZE - 1; //=====Пузырьковая сортировка
                    while (swapped) {                                       // Пока есть обмены, сортируем
                      swapped = 0;
                      for (int i = 1; i < upper_index; i++) {
                        if (PDMset[1][i] < PDMset[1][i - 1]) {
                          uint16_t k = PDMset[1][i];
                          PDMset[1][i] = PDMset[1][i - 1];
                          PDMset[1][i - 1] = k;
                          uint8_t m = PDMset[0][i]; 
                          PDMset[0][i] = PDMset[0][i - 1];
                          PDMset[0][i - 1] = m;
                          swapped = 1;
                        }
                      }
                      upper_index--;
                    } //=====Закончили сортировку
                    old_addr = PDMset[1][0];  // Обновляем адрес самой старой уставки
                  }
                  //
                  if (old_addr) {           // Если в массиве уставок все значения записаны в EEPROM, то стираем самое старое
                    bt.clear_old = 1;       // Ставим флажок стирания (сотрём в следующий вызов подпрограммы опроса кнопок)
                    clear_old_addr = old_addr; // Плодим сущности без устали!
                  }
                  //
                  uint8_t k = PDMset[0][0];
                  for (int x = 0; x < PDMset_SIZE - 1; x++) { // Сдвинем массив
                    PDMset[0][x] = PDMset[0][x + 1];
                    PDMset[1][x] = PDMset[1][x + 1];
                  }
                  //
                  PDMset[0][PDMset_SIZE - 1] = k; // Запишем во временную ячейку свежеудаленное значение
                  PDMset[1][PDMset_SIZE - 1] = 0;
                  PDMcount--;
                  old_addr = PDMset[1][0];    // Обновляем адрес самой старой уставки
                  //
                }
              }
            }
            fl.dspMenu = 0;           //Снимаем флаг перехода в меню
            fl.dspRefresh = 1;        //Ставим флаг обновления экрана
            fl.butt = 0;              //После нажатия должна быть пауза
            break;                    //Закончили
          }
          case 8: { //=====По кнопке "разгон" принимаем и выходим
            PDMust = PDMset[0][PDMcount];//Устанавливаем выбранную мощность ТЭНа
            fl.dspMenu = 0;           //Снимаем флаг перехода в меню
            fl.dspRefresh = 1;        //Ставим флаг обновления экрана
            fl.butt = 0;              //После нажатия должна быть пауза
            break;                    //Закончили
          }
          default:
            fl.butt = 1;              // достаточная пауза между нажатиями
        }
        break;
      }
      default: {  //=============А если не в меню, то...
        switch (bt.butt) {
          case 1:
            if (PDMust > 0) PDMust--;    //Уменьшаем установленную мощность
            break;
          case 2:
            if (PDMust < CICLE) PDMust++; //Увеличиваем установленную мощность
            break;
          case 4:
            if (PDMust == 0) {    //Если мы не в меню и мощность ТЭНа нулевая, то...
              fl.dspMenu = 1;     //Ставим флаг перехода в меню
              fl.dspRefresh = 1;  //Ставим флаг обновления экрана
            }
            else {                //Если мы не в меню и мощность ТЭНа НЕнулевая, то...
                int y = 0;
                for (int x = PDMset_SIZE - 1; x >= 0; x--) {  // Проверим новое значение на совпадение с уже записанными
                  if (PDMust == PDMset[0][x]) {
                    y = 1; break;
                  }
                }
                if (!y) { // Если новое значение действительно новое, то...
                  PDMset[0][PDMset_SIZE - 1] = PDMust;  //Запоминаем текущую мощность ТЭНа
                  PDMset[1][PDMset_SIZE - 1] = 0;       //Адрес зануляем на всякий случай
                  PDMcount = PDMset_SIZE - 1;           //Ставим счетчик на запомненную уставку
                }
                PDMust = 0;         //Экстренно выключаем ТЭН
                fl.razg_on = 0;     //Выключаем разгон
                fl.TRelay = 0;      //Выключаем контактное реле
            }
            fl.butt = 0;          //После нажатия должна быть пауза
            break;                
          case 8:
            fl.razg_on = ((!fl.NotZero) & (!fl.Udown) & (!fl.razg_on)); //Триггер режима разгона (гистерезис организован в обработке начала полупериода)
            fl.razg |= fl.razg_on;                      //Если разгон включили, то твердотельное реле на максимум сразу
            fl.TRelay &= fl.razg_on;                    //Если разгон выключили, то контактное реле выключаем сразу
            fl.butt = 0;                                //После нажатия должна быть пауза
            break;
          default:
            fl.butt = 1;  // достаточная пауза между нажатиями
        }
      }
    }
    butt_count = 1;
    bt.butt = 0;
    Pust = Pnom << 1; Pust *= PDMust; Pust /= CICLE;  Pust++; Pust = Pust >> 1; // Считаем Pust с округлением
    fl.DisplayOut = 1; //Обновление информации на дисплее
  }
} //================================Опрос кнопок=====================
//
ISR(TIMER2_COMPA_vect) { //======Обработчик начала очередного полупериода по таймеру2=========
  //
  #ifdef Debug
    PORTD ^=  (1 << pin_TestOut); //ОТЛАДКА
  #endif
  //
  Razgon_();
  if (pdm) PDM_();  // Не будем зря теребить подпрограмму, если pdm = 0
  else fl.Tout = 0;
//
#ifdef High_level_triac // управление твердотельным реле высоким уровнем
  if (fl.Tout) {
    PORTD |=  (1 << pin_TOut); // Включаем ТЭН
  }
  else {
    PORTD &=  ~(1 << pin_TOut); // Выключаем ТЭН
  }
#else // управление твердотельным реле низким уровнем
  if (fl.Tout) {
    PORTD &=  ~(1 << pin_TOut); // Включаем ТЭН
  }
  else {
    PORTD |=  (1 << pin_TOut); // Выключаем ТЭН
  }
#endif
#ifdef High_level_relay // управление контактным реле высоким уровнем
  if (fl.TRelay) {
    PORTD |=  (1 << pin_TRelay); // Включаем ТЭН
  }
  else {
    PORTD &=  ~(1 << pin_TRelay); // Выключаем ТЭН
  }
#else // управление контактным реле низким уровнем
  if (fl.TRelay) {
    PORTD &=  ~(1 << pin_TRelay); // Включаем ТЭН
  }
  else {
    PORTD |=  (1 << pin_TRelay); // Выключаем ТЭН
  }
#endif
  //
  fl.PP = 1;
//  PVolna *= (-1);
  fl.PVolna = !fl.PVolna;
  OCR2A = PID_ust;                          // Грузим новое значение в регистр сравнения
  //
  sei(); // разрешим прерывания
  Buttons_();   // Опрашиваем кнопки
}//==============================Обработчик начала очередного полупериода по таймеру2=========
//------------------------------------------------------------------------------
ISR(TIMER0_COMPA_vect) { //======Обработчик запуска преобразования АЦП по таймеру0=========
  ADCSRA |=  (1 << ADSC); // Запуск преобразования
}//==============================Обработчик запуска преобразования АЦП по таймеру0=========
//------------------------------------------------------------------------------
ISR(ADC_vect) { //===============Обработчик окончания преобразования АЦП===================
#ifdef Debug
  PORTD |=  (1 << pin_DebugOut);  //ОТЛАДКА
#endif
  static uint8_t   Pcount_sc = 0; // счетчик периодов, за которые просуммированы квадраты отсчетов
  register int32_t temp_32;
  register uint16_t U_adc;
  U_adc = ADCL; U_adc |= ((uint16_t)ADCH) << 8; // забрали результат преобразования АЦП
  register uint8_t TM2_current;
  TM2_current = TCNT2;                      // забрали значение из таймера синхронизации с сетью
  register int16_t U;
  U = 0;
  if (U_adc >= U_ZERO) {
    U_adc -= U_ZERO;  // Убираем постоянную составляющую из оцифрованного сигнала
    U += U_adc;
  }
  else {
    U_adc = U_ZERO - U_adc;
    U -= U_adc;
  }
  //===детекция перехода через ноль и ПИД-синхронизация=================================
  Udelta += (U - Uold);       //
  U = Udelta >> 5;          //КИХ ФНЧ 1-го порядка с коэффициентом 1/32
  //  U = (1*Udelta)/32;          //КИХ ФНЧ 1-го порядка с коэффициентом 1/32
  if ((!fl.zero) && (U >= 0) && (Uold <= 0) && (U != Uold)) { //=======переход через ноль детектед=======
#ifdef Debug
    PORTD |=  (1 << pin_ZeroOut);
#endif
   sc_notzero = 0;    // Обнуляем счетчик выборок АЦП без перехода через ноль
   fl.NotZero = 0;    // Снимаем флажок отсутствия детекции перехода через ноль
  //===Проверка насуммированных отсчетов============================
    if (++Pcount_sc == PSUM_MAX) {          // Насуммировали достаточно
    U_sum = sum; fl.sum = 1; sc_sum = sc;   // Насуммированное готово к обработке
    sc = 0; sum = 0; Pcount_sc = 0;         // Сбрасываем счетчик, сумматор и счетчик полупериодов
  }
  //===Проверка насуммированных отсчетов============================
    fl.zero = 1;
    temp_32 = (TM2_current + Phase) << Km;      // Разность фаз
//    if (PVolna == (-1)) {
    if (!fl.PVolna) {
      temp_32 = temp_32 - PID_reg - (1 << Km);  // Разность фаз должна быть с соответствующим знаком
    }
    PID_int += (temp_32 >> Ki);                 // Считаем интегральную составляющую
    PID_reg += temp_32 >> Kp;                   // Считаем новую функцию управления
    PID_reg += PID_int;
    PID_reg += ( temp_32 - PID_err_old ) >> Kd;
    PID_err_old = temp_32;
    // Готовим данные для записи в регистр сравнения таймера 2
      if ( PID_reg > (255 << Km)) {
        PID_reg = (255 << Km);  // Ограничим сверху
      }
      else if ( PID_reg < (127 << Km)) {
          PID_reg = (127 << Km);  // Ограничим снизу
        }
      temp_32 = PID_reg >> (Km - 1);  // ...и правильно округлим
      temp_32++;                      // используя уже не нужную в этой подпрограмме
      PID_ust = temp_32 >> 1;         // переменную temp_32
    }
 //
  else { //=======переход через ноль  NOT детектед=======
    fl.zero = 0;
    if (++sc_notzero == ZSUM_MAX) {   // Насуммировали достаточно
      fl.NotZero = 1; sc_notzero = 0;
      PID_ust = LINE_FREQ;
      fl.razg_on = 0;       //выключим режим разгона
      pdm = 0; fl.Tout = 0; //выключим твердотельное реле
      fl.TRelay = 0;        //выключим контактное реле
      U_real = 0; sc = 0; sum = 0; Pcount_sc = 0; // Обнулим счетчик, сумматор, счетчик полупериодов и значение напряжения
      fl.DisplayOut = 1;
    }
   //
#ifdef Debug
    PORTD &=  ~(1 << pin_ZeroOut);
#endif
  }
  //
  Uold = U;                   //
  //===детекция перехода через ноль и ПИД-синхронизация=================================
  //
  sei(); // Следующие фрагменты длительны, но не требуют атомарности; разрешим прерывания
  //===Суммирование квадратов=======================================
  temp_32 = U_adc * U_adc;  // Возводим в квадрат выборку АЦП (используем всё ту же переменную temp_32)
  sum += temp_32;           // Суммирование квадратов выборок АЦП
  ++sc;                     // Счетчик выборок АЦП
  //===Суммирование квадратов=======================================
  //
#ifdef Debug
  PORTD &=  ~(1 << pin_DebugOut); //ОТЛАДКА
#endif
}//===============================Обработчик окончания преобразования АЦП===================
//
void setup() {
  fl.dspMenu = 2; // Сначала - начальное меню
  Pins_init();    // Инициализируем входы/выходы
  ADC_init();     // Инициализируем АЦП
  Timers_init();  // Инициализируем таймеры
  sei();          // Разрешаем глобальные прерывания
  //
uint16_t  PPcount = 0;     // счетчик полупериодов
  while (PPcount < 20) {
    PPcount += fl.PP;  // Ждем для гарантированного сброса
    fl.PP = 0;
  }
//
#ifdef DisplayReset
  digitalWrite(pin_OLED_res, HIGH);   // Разрешаем работу дисплея
#endif
//
  while (PPcount < 30) {
    PPcount += fl.PP;  // Ждем для гарантированного разрешения
    fl.PP = 0;
  }
  ASOled.init();                      // Инициализируем OLED дисплей
  ASOled.clearDisplay();              // Очищаем, иначе некорректно работает для дисплеев на SH1106 (косяк библиотеки)
  ASOled.printString_6x8(F("Стабилизатор мощности"), X_centred (21), 0);
  ASOled.printString_6x8(F("ТЭНа"), X_centred (4), 1);
  ASOled.printString_6x8(F(VERSION), X_centred (VERSION_LEN), 3);
  ASOled.printString_6x8(F("JohnJohnov"), X_centred (10), 5);
  ASOled.printString_6x8(F("alcodistillers.ru"), X_centred (17), 7);
  //
  EEPROM_read_Pnoms();  // Прочитаем из EEPROM записанные номиналы ТЭНов
  //
  PPcount = 0;
  while (PPcount < 200) {
    PPcount += fl.PP;  // Пережидаем переходные процессы и любуемся заставкой
    fl.PP = 0;
  }
  ASOled.clearDisplay();
  fl.dspRefresh = 1;
  uart_begin();
}
//
void loop() {
  uart_event();
  //
  if (fl.sum) { //==========Обработка данных от АЦП и корректировка выдаваемой мощности============
#ifdef NOT_LM358
    // 0,55 - Коэффициент нормирования ((380/512)^2, 380В максимальное амплитудное) для Rail-to-Rail операционника
    U_sum /= sc_sum;    //Ненормированный квадрат среднеквадратичного
    U_sum *= 0.55;      //Нормированный квадрат среднеквадратичного
#else
    // 3 - Коэффициент нормирования ((380/220)^2, 380В максимальное амплитудное) для стандартно установленного LM358
    U_sum *= 3;         //Нормированная сумма квадратов среднеквадратичного
    U_sum /= sc_sum;    //Нормированный квадрат среднеквадратичного
#endif
    //=====Корректируем pdm
    register uint32_t tmp; // Величины великоваты, чтобы попасть в размерность приходится считать аккуратно
    //    pdm = U_LINE_Q*PDMust/(U_sum);
    tmp = U_LINE_Q << 1;
    tmp *= PDMust;
    tmp /= U_sum;
    tmp++;
    tmp = tmp >> 1;
    //
    if (tmp > CICLE || fl.razg) { // Следим, чтобы pdm не превышала CICLE
      pdm = CICLE;
      fl.Ulow = !fl.razg; // Или напряжение сети не позволяет выдать установленный уровень мощности или разгон
    }
    else {
      fl.Ulow = 0;
      pdm = tmp;
    }
    // Проверяем величину напряжения
    U_sum *= 400;               // Произведем некоторое математическое колдунство, 
    U_sum = sqrt(U_sum);        // чтобы получить один знак после запятой без float
    U_sum++; U_sum = U_sum >> 1;// и с правильным округлением.
    U_real_dec = U_sum % 10;    //  Среднеквадратичное (дробная часть)
    U_real = U_sum / 10;        //  Среднеквадратичное (целая часть)
    //
    // Контролируем значение
    if ( U_real < 100 ) { //Действующее напряжение сети ниже 100В - отключим ТЭН (авария)
      fl.Udown = 1;       //поставим флажок низкого сетевого
      fl.razg_on = 0;     //выключим режим разгона
      pdm = 0;            //выключим твердотельное реле
      fl.TRelay = 0;      //выключим контактное реле
    }
    else {
      fl.Udown = 0;
    }
    fl.sum = 0;
    fl.DisplayOut = 1; //Обновление информации на дисплее
  } //======================Обработка данных от АЦП и корректировка выдаваемой мощности============
  //
  if (fl.DisplayOut) { //========================Вывод информации на дисплей=============  
    switch (fl.dspMenu) { //=====Проверяем режимы меню
      case 2:  {  //=============Если мы в начальном меню, то...
        if (fl.dspRefresh) {  //Обновляем дисплей
          ASOled.clearDisplay();
          ASOled.printString_6x8(F("Выберите/введите Pном"), 0, 0);
          ASOled.printString_6x8(F("Pном=      Вт, (230В)"), 0, 1);
          ASOled.printString_6x8(F("---------------------"), 0, 2);
          ASOled.printString_6x8(F(" Управление:"), 0, 3);
          ASOled.printString_6x8(F("P- Выбор/уменьшение"), 0, 4);
          ASOled.printString_6x8(F("P+ Увеличение"), 0, 5);
          ASOled.printString_6x8(F("Ст Принять и записать"), 0, 6);
          ASOled.printString_6x8(F("Рз Принять без записи"), 0, 7);
        }
        static uint16_t Pnomold = 0;
        if (!Pnom || Pnom > 9999) {
          Pnomold = Pnom;
          ASOled.printString_6x8(F("****"), X_position (6), 1);
        }
        else if ((Pnomold != Pnom) || fl.dspRefresh) {
          Pnomold = Pnom;
          ASOled.printString_6x8(F("    "), X_position (6), 1);
          ASOled.printNumber((long)Pnom, X_position (9,Pnom), 1);
        }
        fl.dspRefresh = 0;
        break;
      }
      case 1:  {  //=============Если мы в меню выбора уставки, то...
        if (fl.dspRefresh) {  //Обновляем дисплей
          ASOled.clearDisplay();
          ASOled.printString_6x8(F("Выберите уставку"), 0, 0);
          ASOled.printString_6x8(F("Pуст=      Вт"), 0, 1);
          ASOled.printString_6x8(F("---------------------"), 0, 2);
          ASOled.printString_6x8(F(" Управление:"), 0, 3);
          ASOled.printString_6x8(F("P- Выбор"), 0, 4);
          ASOled.printString_6x8(F("P+ Выбор"), 0, 5);
          if (fl.writable) {  // Если уставки пишутся в EEPROM, то...
            ASOled.printString_6x8(F("Ст Принять и записать"), 0, 6);
          }
          else {  // а если уставки не пишутся в EEPROM, то...
            ASOled.printString_6x8(F("Ст Принять без записи"), 0, 6);
          }
          ASOled.printString_6x8(F("Рз Принять без записи"), 0, 7);
        }
        static uint8_t PDMold = 0;
        if ((PDMold != PDMset[0][PDMcount]) || fl.dspRefresh) {
          PDMold = PDMset[0][PDMcount];
          uint32_t p = Pnom << 1; p *= PDMold; p /= CICLE;  p++; p = p >> 1; // Считаем уставку с округлением
          ASOled.printString_6x8(F("    "), X_position (6), 1);
          ASOled.printNumber((long)p, X_position (9,p), 1);
          if (PDMset[1][PDMcount]) {  // Если значение записано в EEPROM
            ASOled.printString_6x8(F("R"), X_position (20), 1);   // Поставим значок
          }
          else ASOled.printString_6x8(F(" "), X_position (20), 1);// а если не записано - уберем
        }
        fl.dspRefresh = 0;
        break;
      }
      default: {  //=============А если не в меню, то...
        #define str_Ureal 0
        #define str_Ustat 1
        #define str_ust 3
        #define str_Pnom 6
        #define str_Razgon 4
        #define str_Relay 7
        //
        if (fl.dspRefresh) {  //Обновляем дисплей
          ASOled.clearDisplay();
          ASOled.printString_6x8(F("Напр.сети        ,  В"), 0, str_Ureal);
          ASOled.printString_6x8(F("Pуст      Вт;    ,  %"), 0, str_ust);
          ASOled.printString_6x8(F("Pном      Вт"), 0, str_Pnom);
          ASOled.printNumber((long)Pnom, X_position (8,Pnom), str_Pnom);
        }
        //
        static uint16_t U_real_old = 0;
        if ((U_real_old != U_real) || fl.dspRefresh) {
          U_real_old = U_real;
          ASOled.printString_6x8(F("    "), X_position (13), str_Ureal);
          ASOled.printNumber((long)U_real_old, X_position (16,U_real_old), str_Ureal);
        }
        static uint8_t U_real_dec_old = 0;
        if ((U_real_dec_old != U_real_dec) || fl.dspRefresh) {
          U_real_dec_old = U_real_dec;
          ASOled.printNumber((long)U_real_dec_old, X_position (18), str_Ureal);
        }
        static uint16_t Pust_old = 0;
        if ((Pust_old != Pust) || fl.dspRefresh) {
          Pust_old = Pust;
          ASOled.printString_6x8(F("    "), X_position (5), str_ust);
          ASOled.printNumber((long)Pust_old, X_position (8,Pust_old), str_ust);
        }
        //
        static uint8_t PDMust_old = 0;
        if ((PDMust_old != PDMust) || fl.dspRefresh) {
          PDMust_old = PDMust;
          ASOled.printString_6x8(F("    "), X_position (13), str_ust);
          ASOled.printNumber((long)(PDMust_old/2), X_position (16,(PDMust_old/2)), str_ust);
          ASOled.printNumber((long)(PDMust_old & 1)*5, X_position (18), str_ust);  
        }
        fl.dspRefresh = 0;
        //
        if (fl.Udown || fl.NotZero) {
          ASOled.printString_6x8(F("-----Авария сети-----"), 0, str_Ustat);
        }
        else if (fl.Ulow) {
          ASOled.printString_6x8(F("--Недост.напр. сети--"), 0, str_Ustat);
        }
        else {
          ASOled.printString_6x8(F("---------------------"), 0, str_Ustat);
        }
      //
        if (fl.razg_on) {
          static uint8_t count_1 = 0;
          byte x1 = 5 - count_1;
          byte x2 = 20 - x1;
          ASOled.printString_6x8(F("------<Разгон!>------"), 0, str_Razgon);
          ASOled.printString_6x8("<", X_position (x1), str_Razgon);
          ASOled.printString_6x8(">", X_position (x2), str_Razgon);
          if (++count_1 > 5) count_1 = 0;
        }
        else {
          ASOled.printString_6x8(F("---------------------"), 0, str_Razgon);
        }
        //
        if (fl.TRelay) {
          ASOled.printString_6x8(F("Реле включено"), X_position (0), str_Relay);
        }
        else {
          ASOled.printString_6x8(F("             "), X_position (0), str_Relay);
        }
      }
    }
  //
      fl.DisplayOut = 0;
 }//========================Вывод информации на дисплей=============  
}
